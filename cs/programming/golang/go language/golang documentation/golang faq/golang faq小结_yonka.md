

**golang目标**

> background

> > 1 电脑越来越快，而软件开发的加速则没有跟上
>
> > 2 依赖管理是当下软件开发重要的一部分，但传统的C 头文件方式则不利于依赖分析和快速编译
>
> > 3 人们对java、c++等语言的笨重的类型系统越来越反感，将其推向py、js等动态类型语言
>
> > 4 主流系统语言对gc和并行计算的支持不是那么好
>
> > 5 多核计算机的出现带来了一些担忧和困惑

> 目标

> > 1 可以在一台电脑上以几秒的时间编译一个大型go程序
> >
> > 2 go 提供一个便于依赖分析和避免C风格的引入文件和二进制的负荷的软件构建模型
> >
> > 3 go 的类型系统没有层级，于是不会花费时间来定义类型之间的关系。 同时虽然go有静态类型但也尽量让类型感觉起来比典型OO语言更轻量
> >
> > 4 go完全支持gc并且提供对并发执行和通信的基础支持
> >
> > 5 基于语言设计，提供了一种多核机器上的系统软件构建的方式

> 更多见《Go at Google: Language Design in the Service of Software Engineering》

**golang项目状态**

> ...

**golang项目历史**

> ...

**创建新语言的目的**

> 基于已有系统编程语言的不足/痛点 - 高效编译、高效执行、高效编程 难以兼具。
>
> go企图把 解释性、动态类型语言 和 静态类型、编译型语言 的优点合在一起。 同时也针对 对新的网络编程和多核编程。 
>
> ...

**golang的家族谱**

> C系，也采纳了部分 Pascal/modula/oberon系的特点（声明、包），也有一些被CSP启发的想法

**设计的指导原则**

> 减少二义性，减少混乱和复杂度
>
> 不需要预先声明和头文件，只声明一次
>
> 语法简明，关键字少
>
> 声明+赋值的操作用 := 来简化
>
> 最彻底/激进/根本的： 没有类型集成，类型只需要关心是什么，而不需要关心类型之间的关系
>
> 保持概念正交： 可以为任何类型实现方法，（数据的）结构表示数据 而 接口表示抽象。 正交使得更容易在事物混合时明确在做什么。

**与c/c++程序的链接**

> 两个go的编译器实现： gc 和 gccgo
>
> gc： 使用不同的 call convention 和 linker，因此只能与使用同样convention的c程序链接 （有这样的c编译器，但没有这样的c++编译器，于是...）
>
> gccgo： gcc前端，可以和gcc编译的c/c++程序链接
>
> cgo提供了安全的在go代码里调用c库的接口（FFI，外部语言调用），SWIG则将该能力扩展到C++库。

**unicode标示符identifier**

> 规则： go的标示符需要是 unicode可以表示的letters 或 digits
>
> 但对于导出的标示符需要大写字母开头的原则不太可能改变，导致可能需要 X日本 这样的变量名。

**go的特定 - 为什么没有X特性**

> 简而言之，作者是有考虑的，不包含的特性或许也是很好的，但不符合go的定位和方向、格局。

**为什么没有泛型**

> 以后可能会加入，但不是很紧急。
>
> 泛型很方便，但会增加类型系统和运行时的复杂度。 目前还没有找到适中的方式。 会继续考虑。

**为什么没有异常**

> 作者认为异常会使得代码变复杂，同时也鼓励开发者把各种普通的错误作为异常。
>
> go中对于普通的错误处理，使用返回err值的方式... （通过多返回值...）
>
> 而对于真正的异常情况，有内建的函数来signal & recover。 恢复机制只在发生错误后函数的状态为...时执行...

**为什么没有断言**

> go不支持断言。 不可否则断言很方便，但作者认为开发者过于依赖断言了，以逃避合适的处理操作。 ...
>
> 作者理解这一点确实有争议，但跟其他...一样，go里很多东西和其他语言不通，正是因为想找另一条出路

**为什么内建支持CSP并发**

> 并发和多线程编程 一直被视为难题，作者认为 部分因为pthread的复杂设计 而 另一部分由于过分强调底层的细节： 互斥量、条件变量、内存屏障。 高层的接口可以使得代码更简单，虽然底层还是使用这些...
>
> Hoare的CSP是最成功的提供并发高层语言支持的模型之一。 occam和erlang都源自CSP。 go的并发原语来自该家族树family tree中的另外一部分： 强大的作为一级类对象的channel的概念。 更早一些的语言的经验显示 CSP模型很适合过程语言框架。

**为什么用协程代替线程**

> goroutine是一种使得并发更容易使用的方式。 使得执行函数的过程（协程coroutine）独立的复用到一组线程。 
>
> coroutine阻塞时（如调用阻塞系统调用），运行时会自动把当前线程上的协程移到其他（未阻塞）线程。 而这些对开发者是不可见的。 效果就是调用goroutine的成本很低： overhead（栈内存）很小，只有几K。
>
> 为了让栈尽量小，go运行时使用可调整大小的有界的栈。 新的协程只有几K，而且几乎总是够用的。 当不够用的时候，运行时会自动增加/减少栈内存，使得在许多goroutine使用适量的内存。 CPU的开销则约为每个函数三个低开销的指令。 实践表明可以在一个地址空间里创建百万级别的协程。 而如果是线程的话，支持的数量就要远远少于这个数了。

**为什么map的操作不是原子性的**

> 经讨论决定： map的主要用途并不需要在多goroutine之间安全访问，而如果需要的话，可以将map作为其他数据结构的一部分，或者通过其他方式老保证同步。
>
> 这是一个艰难的决定： 不受控的map访问会crash整个程序。
>
> --- 语言层面并不阻止原子的map更新，需要的时候实现可以interlock map的访问。

**是否接受修改提议**

> 开源、开放，但如果提议违背了go 1 specification的话，将不被... 即使是有益的。
>
> 也许未来的版本不会兼容go 1，但起码不在当下的考虑之内
>
> 即使提议符合go 1 spec，但不一定与go的设计目标贴合...

**--- 类型**

**go是不是OOL**

> 是，也不是。
>
> go有类型和方法，允许以OO的风格编程。 但是没有类型继承。
>
> go中的接口也（和主流的）有所不同（duck typing）
>
> 有办法来嵌入类型到其他类型来提供跟子类（subclassing）类似的功能， 但并不一样。
>
> go中的方法比c++和java中的更通用，可以为任意数据，即使是内建的类型如基本类型（unboxed integers ...）
>
> 缺少类型的层级也是的go里的“对象”显得轻量的多。

**怎样做到方法的动态dispatch**

> 唯一方式是通过接口。 结构体和其他concrete具体类型的方法都是静态解析的。

**为什么没有类型继承**

> go不想像典型的OO语言一样花费太多的...在类型的关系上。 go希望用duck typing而不是显式声明...。 类型和接口之间没有显式的关系... 也没有类型层级...

**为什么len是函数而不是方法**

> = = 经讨论...

**为什么不支持方法和操作符的重载**

> 不支持方法重载的话 - method dispatching时不需要做type matching - 简化...
>
> 作者觉得重载并不是很常用，没必要花费...代价来支持
>
> 对于运算符重载，作者认为不是强需求而只是遍历，同样的，觉得宁可没有保持更简单。

**为什么没有 implements 这个标示符声明**

> duck typing... 不需要...
>
> 同样，也是为了前面提到的原则： 类型和接口尽量不要有显式的关系。 隔离概念，重用代码... = =

**如何确保类型实现了/满足接口**

> ```
> type T struct {}var _ I = T{}  // 确保T实现了Ivar _ I = (*T)(nil)  // 确保*T实现了I// 如果还是希望类型显式的表示实现了接口，可以在接口里加一个类似 ImplementsI 的方法 = =，如：type Fooer interface {    Foo()    ImplementsFooer()}type Bar struct{}func (b Bar) Foo(){}func (b Bar) ImplementsFooer(){}  // 通过这个丑陋的东西来“显式”表明实现了Fooer接口
> ```

**为什么类型T没有满足 Equal 接口**

> ```
> type Equaler interface {    Euqal(Equaler) bool}type T intfunc (t T) Equal(u T) bool {return t == u}// 上面的代码是不行的，T并没有实现Equaler接口，因为跟其他多态类型系统的类似情况不同，Equal的参数类型是Equaler，而不是T implements Equaler。// 下面的代码才可以type T2 intfunc (t T2) Equal(u Equaler) bool {return t == u.(T2)}// 类似的，下面的也不行，T3并没有实现Opener接口type Opener interface {    Open() Reader}func (t T3) Open() *os.File
> ```
>
> 这种情况下，go的类型系统做的事情比开发者想的（类似其他语言中的）少。 需要...精确匹配函数签名的类型部分。

**怎么把 []T 转为 []interface{}**

> 没有直接的办法，因为go没有协变类型（逆变也没有 = =），所以... 没关系... 只能用stupid方式， 创建 - 遍历 - add

**为什么nil error值不等于nil**

> 接口类型的实现里有两个字段： 类型、值 （类似 (t, v)）。 这个值称为接口的动态值，可以是任意的具体类型值； 类型则是该值的具体类型。 如对于 int值3，接口的话则类似(int, 3)；对于 *int则类似 (*int, 0x2a213b)
>
> 接口的值 == nil 必须满足： t == nil && v == nil。 接口类型的默认值就是这个。 但对于下面的场景：
>
> ```
> type MyError struct {}func (e *MyError) Error() string {}func returnsError() error {    var p *MyError = nil    if bad() {        p = ErrBad    }    return p  // 将永远返回non-nil的error}
> ```
>
> line 5 中p赋值为nil执行完后，p就是 nil 指针了。 把p当error返回时可以的，但此时得到的是 (*MyError, nil) ，所以 != nil。
>
> 应该使用下面的：
>
> ```
> func returnsError() error {    if bad() {        return ErrBad    }    return nil}
> ```

**为什么没有C里边那种 untagged unions**

> 因为其违背了go的内存安全保证。
>
> ```
> union reg_a {  uint32_t    full;  struct {    /* little-endian in this example */    uint16_t  low;    uint16_t  high;  } __attribute__((__packed__));};union reg_a a;a.full = 0x12345678; /* set all whole 32-bits */a.high = 0xffff;      /* change the upper 16-bits */union pix_rgba {  uint32_t    pix;    /* to access the whole 32-bit pixel at once */  struct {    uint8_t   red;    /* red component only */    uint8_t   green;  /* green component only */    uint8_t   blue;   /* blue only */    uint8_t   alpha;  /* alpha only */  } __attribute__((__packed__));};
> ```
>
> ![img]()

**为什么go没有协变类型**

> \# 如java里的数组
>
> 考虑过加入但讨论后还是决定不。 因为他们跟接口的功能重叠了，会导致混淆。
>
> 而且 协变类型的应用场景部分已经由其他功能覆盖了，比如接口，虽然不太优雅，但也可行 （ = = ）

**--- 值**

**为什么go不提供隐式的数值的转换**

> 1 可移植性
>
> 2 简化编译器

**为什么map是内建**

> 常用、作者认为实现的足够好可以应付大多数场景

**为什么maps不支持slice作为key**

> key需要支持 == 操作，但slice不支持。 --- slice的 == 不好定义： 浅/深层比较？ 指针/值比较？ 递归类型怎么处理？ ...

> go 1以后，对于struct和array的==做了定义，所以可以作为...

**为什么maps、slices、channels都是引用而数组是值**

> 历史演进。 原先 maps、channels都是指针，无法声明或使用非指针instance。 后来决定严格的分隔指针和值使得语言难以使用，于是把这些类型变成类似引用的东西...
>
> 带来的令人遗憾的复杂度，但在易用性上也有很大的好处。

**--- 写代码**

**库文档在哪**

> godoc ..

**有没有go的编程风格指南**

> 参见effective Go、go code review comment，以及使用gofmt

**怎么给go库提交patch**

> 现在mailing list讨论再提交...

**为什么go get在clone repo的时候使用https**

> 很多公司会block git的9418和ssh的22端口。一般放开的多是80和443，而为了安全考虑， 所以... 

> 如果希望用git的话， 可以自行：

> cd $GOPATH/src/github.com/username

> git clone git@github.com:username/package.git

**怎么使用go get来管理依赖包的版本**

> go get并没有显式的包版本的概念。作者认为包应该维持后向兼容（ = =）... 并且认为使用者为了自身“安全”考虑，可以自行fork再使用... = = 如 original.com/plg ---> you.com/external/original.com/pkg
>
> 可以用 gomvpkg程序来帮助自动化该过程。
>
> go1.5包含了一项实验性的...来帮助管理外部依赖，通过把它们 vendoring到特别的目录的方式... 参见 go 1.5 vendor <https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit> 

**--- 指针和（内存）分配**

**函数传参什么时候是值传递**

> 和c系的所有语言一样，go中的任何东西都是值传递的，也即函数获得的都是一份copy。 对于int获得一份int的copy，对于 *int获得一份*int的copy（也即指针的“值”的copy，不是指针指向的值的copy）

> map、slice 有点像指针，但实际是wrap了指针的struct。 --- 起到了类似引用的效果

**什么时候应该使用对于接口的指针（pointer to an interface）**

> 几乎绝对不。 使用接口的指针只会导致罕见而奇怪的问题。
>
> 不过有一个常见的错误就是传递一个 接口类型值的指针到一个期待接口类型参数的函数。
>
> 如：
>
> var w io.Writer
>
> fmt.Fprintf(w, "hello, world\n")
>
> // fmt.Fprintf(&w, "hello, world\n")  // will not compile
>
> 
>
> 唯一的例外是： 任何值、哪怕是接口值的指针，都可以赋值给空接口类型变量。 即使这样，也不应该这么实用。

**方法应该定义在值上还是指针上**

> 定义在值上的，可以被值和指针调用。
>
> 定义在指针上的，只能被指针调用。
>
> 注意： slice、map是类似引用的存在（其实还是特殊的struct），如果只读或者只按索引赋值的话可以传值。 但如果要改变其长度的话则需要指针，如 &s
>
> 如果很大的struct，一般尽量传指针，也即方法尽量定义在指针上。
>
> 此外就是一致性，比如调用的其他方法也需要指针，则一般需要指针...
>
> 如果用指针来调定义在值上的方法... --- 应该还是会发生值拷贝，类似 vp := &v; v1 := *vp

**new和make的区别是？**

> new： 分配内存
>
> make：初始化 slice、map和channel

**64位机器上int的size是多少**

> int和uint的长度是实现相关的，不过在指定的平台上长度相等。
>
> 为了可移植性，依赖确切长度的...不应该使用这两个，而是使用确定的...
>
> 在1.1之前，64bit的go编译器使用int32来表示int，而从1.1开始，会使用64bit来表示。
>
> 另外，浮点和负数永远是确定的： float32 和 complex64 ...

**如何知道变量时分配在栈上还是堆上**

> 存储位置是由实现根据语言的语义来选择而的。
>
> 存储位置确实对写一个高效的程序有影响。 如果可以的话，go编译器会在函数的栈帧（local to the funtion）里分配变量。 然而如果编译器不能确定该变量不会在函数返回后被引用的话，它必须在gc堆里分配该变量以避免导致指针错误。 而且如果本地变量很大的话，也会可能分配在堆里。
>
> 在当前的编译器里，如果变量做了取地址操作的话，则有可能（is a candidate for allocation on the heap）分配在堆里。 不过，会做基本的逃逸分析，如果确认函数返回后不会再访问的话，也还是会分配在栈内。

**为什么我的go程序使用了很多的虚拟内存**

> go的内存分配其会预留一大块虚拟内存来作为内存分配的arena = =
>
> 该虚拟内存是go进程的本地内存，不会剥夺其他进程的内存
>
> 用 top命令看RES部分可以获知分配给go进程的实际内存。

**--- 并发**

**什么操作是原子性的，mutex呢？**

> 目前没有完整定义，参见 Go Memory Model specification
>
> 对于mutex，sync包有实现，但希望go的编程风格会鼓励人们尽量尝试高层次的技术，尤其是考虑把程序组织成在同一时刻只有一个goroutine负责同一片数据。
>
> --- 不要通过共享内容的方式来通信，而是通过通信的方式共享内存

**为什么我的多协程程序没有使用多CPU**

> 同时执行goroutine的CPU的数目由 GOMAXPROCS 确定（环境变量）。 在早版本的go中默认为1,1.5开始默认值为CPU核数。
>
> ...

**为什么使用 GOMAXPROCS>1的设置有时使得程序变慢**

> 要看程序的性质，顺序的程序没法通过增加goroutine来加速； 只有并行的程序才能...
>
> 从本质上来看，那些花费在channel间通信的时间多于计算的程序会在使用多线程的时候遭遇性能下降... 因为在线程间发送数据会涉及上下文切换，会有显著的代价。 
>
> go的goroutine调度器尽管在最近的版本里有所改善，但还是没达到应有的程度。 将来会优化对OS线程的使用。 当下如果有性能问题，根据应用来设置GOMAXPROCS会比较好。

**--- 函数和方法**

**为什么T和\*T有不同的方法集**

> T的方法集： 定义在T上的；
>
> *T的方法集： 定义在T和*T上的

**goroutine运行闭包会发生什么？**

> 并发使用闭包可能会带来一些困惑。
>
> 比如循环的声明块中定义的变量问题...

> > ```
> > func main() {    done := make(chan bool)    values := []string{"a", "b", "c"}    for _, v := range values {        go func() {            fmt.Println(v)            done <- true        }()    }    // wait for all goroutines to complete before exiting    for _ = range values {        <-done    }}
> > ```

> 解决办法：
>
> 1 作为参数传入

> > ```
> >     for _, v := range values {        go func(u string) {            fmt.Println(u)            done <- true        }(v)    }
> > ```

> 2 赋给循环内作用域局部变量

> > ```
> >     for _, v := range values {        v := v // create a new 'v'.        go func() {            fmt.Println(v)            done <- true        }()    }
> > ```

**--- 控制流**

**go有没有三目运算符 ?: ？**

> 不... 用if结构代替

**如何创建多文件的包**

> 直接创建多个文件即可... 不过要属于同一个包（除了*test包以外）

**怎么写单元测试**

> *_test.go
>
> func Test*(t *testing.T) {}

**测试时我最喜欢的工具方法在哪里？**

> ...

**为什么X不在标准库里**

> ... 
>
> 建议新的代码不要加入到标准库...

**--- 实现**

**用什么技术来build编译器**

> gccgo 有一个c++写的前端，附带一个耦合到标准gcc后端的 递归逆序解析器。
>
> gc则用go编写，用yacc/bison作为解析器，使用一个自定义的也是go写的加载器，不过基于plan 9加载器，来产生ELF/Mach-O/PE二进制文件。
>
> 考虑过为gc使用LLVM（作为后端），但感觉太大了而且速度达不到性能目标
>
> 原先的gc是用c写的（由于自启的难题），需要用go的编译器来建立go环境。 不过在go1.5有所进展，编译器用go写了。 用自动翻译工具从c翻译为go。
>
> 由于编译器self-hosting，所以面对自启问题。 解决办法是安装老的go，然后用来编新的go = =

**运行时是怎么实现的**

> 因为自启的原因，最开始运行时的代码基本都收C写的（极少数汇编），不过已经翻译到go了（除了少数汇编）。

> gccgo的运行时支持用到了glibc。 gcc编译器用一种叫做“ 分段栈”的技术来实现goroutines。 supported by recent modifications to the gold linker.

**为什么一个小程序会编成一个大二进制文件**

> gc的linker默认会创建静态链接的二进制，所以所有的go二进制都会包含go的运行时，以及用于动态类型检查、反射 甚至还有panic-time栈检查的运行时类型信息。

**可以避免对未使用的变量/导入的报错吗**

> 强制编程习惯
>
> 之所以没有接受那些允许添加编译器选项来关闭这些检查的建议： 编译器轩轩不应该影响语言的语义，而go编译器并没有报错，只是有错误阻止了编译

**--- 性能**

**为什么go在benchmark X上表现的不好？**

> 一些...做的对比并不恰当...
>
> raw performance接近
>
> 改进gc和一些库的性能

**--- 相比C的变化**

**为什么go和c的语法有这么大的差异？**

> 除了声明以外，其他的语法差异并不大。
>
> 两个期望：
>
> 1 语法尽量轻量，关键字少点
>
> 2 尽量容易分析和解析（analyze、parse），不需要symbol表就可以解析 --- 便于编写debuggers等工具、分析依赖、自动文档提取、IDE插件等

**为什么声明在后呢？**

> 只是对于习惯了C风格来说才会觉得奇怪。 C里类型在前的方式使得声明操作类似表达式，但 类型和表达式的语法混在一起的效果并不好，结果也可能让人困惑，比如 函数指针...
>
> ...

**为什么没有指针运算**

> 为了安全。 不支持指针运算可以使得语言不会产生一个非法的地址。 
>
> 编译器和硬件技术使得用数组下标访问数组的效率可以和用指针运算一样...
>
> 同时还可以简化GC。

**为什么++和--是语句statement而不是表达式expression，为什么是后缀而不是前缀？**

> 没了指针运算以后，这两个运算符带来的便利已经降低了。 把它们从表达式移除以后 表达式语法得以简化，而++和--给evaluation带来的混乱也被消除了。 
>
> 对于先后的问题，两者都可以，不过后缀方式更传统一些... 

**为什么不能有大括号但没有分号？为什么不能把左大括号放在新的一行？**

> go使用 大括号来组织语句（grouping statement），类似C系语言。
>
> 分号是给parsers而不是程序猿，所以希望尽量消除。
>
> 从BCPL借了一招： 分隔语句的分号会在正式的语法中，但可以自动注入.. without lookahead, by the lexer at the end of any line that could be the end of a statement
>
> 这个方式在实践中运作的很好，但带来一个副作用： 强制括号风格，比如 左大括号不能单独存在于一行。
>
> 此外，由于go代码应该由gofmt来格式化，所以实际上没必要为此来改变解析... 

**为什么用GC？会不会代价太大？**

> 系统编程里最大的问题之一就是内存管理。 我们觉得很重要的一点是 程序猿的负担 以及 近些年来GC技术给我们信心可以用足够低的开销和不明显的延时来实现GC
>
> 此外，并发和多线程编程很大的问题之一也是内存管理。 对象在线程之间传递，很难保证他们被安全的释放。 自动GC使得并发的代码容易写的多。 
>
> 在并发环境下实现GC本身就是一个挑战，但实现它比在每个程序里实现（内存管理）要好得多。
>
> 最后，除了并发以外，gc也是的接口更容易，因为不需要指定内存在他们之间怎么管理。
>
> 目前的实现是并行标记清除（PMS）收集器。 以后可能尝试新的方式。
>
> 在性能方面，go给了程序猿相当程度的对内存分配的控制，远多于主流的GC语言。 小心的程序猿可以显著的减少GC负担。 



