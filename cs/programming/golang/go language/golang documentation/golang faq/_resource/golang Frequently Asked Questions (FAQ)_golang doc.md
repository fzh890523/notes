

# Frequently Asked Questions (FAQ)

| [Origins](http://golang.org/doc/faq#Origins)[What is the purpose of the project?](http://golang.org/doc/faq#What_is_the_purpose_of_the_project)[What is the status of the project?](http://golang.org/doc/faq#What_is_the_status_of_the_project)[What is the origin of the name?](http://golang.org/doc/faq#What_is_the_origin_of_the_name)[What's the origin of the mascot?](http://golang.org/doc/faq#Whats_the_origin_of_the_mascot)[What is the history of the project?](http://golang.org/doc/faq#history)[Why are you creating a new language?](http://golang.org/doc/faq#creating_a_new_language)[What are Go's ancestors?](http://golang.org/doc/faq#ancestors)[What are the guiding principles in the design?](http://golang.org/doc/faq#principles)[Usage](http://golang.org/doc/faq#Usage)[ Is Google using Go internally?](http://golang.org/doc/faq#Is_Google_using_go_internally)[Do Go programs link with C/C++ programs?](http://golang.org/doc/faq#Do_Go_programs_link_with_Cpp_programs)[Does Go support Google's protocol buffers?](http://golang.org/doc/faq#Does_Go_support_Google_protocol_buffers)[Can I translate the Go home page into another language?](http://golang.org/doc/faq#Can_I_translate_the_Go_home_page)[Design](http://golang.org/doc/faq#Design)[What's up with Unicode identifiers?](http://golang.org/doc/faq#unicode_identifiers)[Why does Go not have feature X?](http://golang.org/doc/faq#Why_doesnt_Go_have_feature_X)[Why does Go not have generic types?](http://golang.org/doc/faq#generics)[Why does Go not have exceptions?](http://golang.org/doc/faq#exceptions)[Why does Go not have assertions?](http://golang.org/doc/faq#assertions)[Why build concurrency on the ideas of CSP?](http://golang.org/doc/faq#csp)[Why goroutines instead of threads?](http://golang.org/doc/faq#goroutines)[Why are map operations not defined to be atomic?](http://golang.org/doc/faq#atomic_maps)[Will you accept my language change?](http://golang.org/doc/faq#language_changes)[Types](http://golang.org/doc/faq#types)[Is Go an object-oriented language?](http://golang.org/doc/faq#Is_Go_an_object-oriented_language)[How do I get dynamic dispatch of methods?](http://golang.org/doc/faq#How_do_I_get_dynamic_dispatch_of_methods)[Why is there no type inheritance?](http://golang.org/doc/faq#inheritance)[Why is len a function and not a method?](http://golang.org/doc/faq#methods_on_basics)[Why does Go not support overloading of methods and operators?](http://golang.org/doc/faq#overloading)[Why doesn't Go have "implements" declarations?](http://golang.org/doc/faq#implements_interface)[How can I guarantee my type satisfies an interface?](http://golang.org/doc/faq#guarantee_satisfies_interface)[Why doesn't type T satisfy the Equal interface?](http://golang.org/doc/faq#t_and_equal_interface)[Can I convert a [\]T to an []interface{}?](http://golang.org/doc/faq#convert_slice_of_interface)[Why is my nil error value not equal to nil?](http://golang.org/doc/faq#nil_error)[Why are there no untagged unions, as in C?](http://golang.org/doc/faq#unions)[Why does Go not have variant types?](http://golang.org/doc/faq#variant_types)[Values](http://golang.org/doc/faq#values)[Why does Go not provide implicit numeric conversions?](http://golang.org/doc/faq#conversions)[Why are maps built in?](http://golang.org/doc/faq#builtin_maps)[Why don't maps allow slices as keys?](http://golang.org/doc/faq#map_keys)[Why are maps, slices, and channels references while arrays are values?](http://golang.org/doc/faq#references)[Writing Code](http://golang.org/doc/faq#Writing_Code) | [How are libraries documented?](http://golang.org/doc/faq#How_are_libraries_documented)[Is there a Go programming style guide?](http://golang.org/doc/faq#Is_there_a_Go_programming_style_guide)[How do I submit patches to the Go libraries?](http://golang.org/doc/faq#How_do_I_submit_patches_to_the_Go_libraries)[Why does "go get" use HTTPS when cloning a repository?](http://golang.org/doc/faq#git_https)[How should I manage package versions using "go get"?](http://golang.org/doc/faq#get_version)[Pointers and Allocation](http://golang.org/doc/faq#Pointers)[When are function parameters passed by value?](http://golang.org/doc/faq#pass_by_value)[When should I use a pointer to an interface?](http://golang.org/doc/faq#pointer_to_interface)[Should I define methods on values or pointers?](http://golang.org/doc/faq#methods_on_values_or_pointers)[What's the difference between new and make?](http://golang.org/doc/faq#new_and_make)[What is the size of an int on a 64 bit machine?](http://golang.org/doc/faq#q_int_sizes)[How do I know whether a variable is allocated on the heap or the stack?](http://golang.org/doc/faq#stack_or_heap)[Why does my Go process use so much virtual memory?](http://golang.org/doc/faq#Why_does_my_Go_process_use_so_much_virtual_memory)[Concurrency](http://golang.org/doc/faq#Concurrency)[What operations are atomic? What about mutexes?](http://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes)[Why doesn't my multi-goroutine program use multiple CPUs?](http://golang.org/doc/faq#Why_no_multi_CPU)[Why does using GOMAXPROCS > 1 sometimes make my programslower?](http://golang.org/doc/faq#Why_GOMAXPROCS)[Functions and Methods](http://golang.org/doc/faq#Functions_methods)[Why do T and *T have different method sets?](http://golang.org/doc/faq#different_method_sets)[What happens with closures running as goroutines?](http://golang.org/doc/faq#closures_and_goroutines)[Control flow](http://golang.org/doc/faq#Control_flow)[Does Go have the ?: operator?](http://golang.org/doc/faq#Does_Go_have_a_ternary_form)[Packages and Testing](http://golang.org/doc/faq#Packages_Testing)[How do I create a multifile package?](http://golang.org/doc/faq#How_do_I_create_a_multifile_package)[How do I write a unit test?](http://golang.org/doc/faq#How_do_I_write_a_unit_test)[Where is my favorite helper function for testing?](http://golang.org/doc/faq#testing_framework)[Implementation](http://golang.org/doc/faq#Implementation)[What compiler technology is used to build the compilers?](http://golang.org/doc/faq#What_compiler_technology_is_used_to_build_the_compilers)[How is the run-time support implemented?](http://golang.org/doc/faq#How_is_the_run_time_support_implemented)[Why is my trivial program such a large binary?](http://golang.org/doc/faq#Why_is_my_trivial_program_such_a_large_binary)[Can I stop these complaints about my unused variable/import?](http://golang.org/doc/faq#unused_variables_and_imports)[Performance](http://golang.org/doc/faq#Performance)[Why does Go perform badly on benchmark X?](http://golang.org/doc/faq#Why_does_Go_perform_badly_on_benchmark_x)[Changes from C](http://golang.org/doc/faq#change_from_c)[Why is the syntax so different from C?](http://golang.org/doc/faq#different_syntax)[Why are declarations backwards?](http://golang.org/doc/faq#declarations_backwards)[Why is there no pointer arithmetic?](http://golang.org/doc/faq#no_pointer_arithmetic)[Why are ++ and -- statements and not expressions?  And why postfix, not prefix?](http://golang.org/doc/faq#inc_dec)[Why are there braces but no semicolons? And why can't I put the openingbrace on the next line?](http://golang.org/doc/faq#semicolons)[Why do garbage collection?  Won't it be too expensive?](http://golang.org/doc/faq#garbage_collection) |
| ---------------------------------------- | ---------------------------------------- |
|                                          |                                          |

## Origins

### What is the purpose of the project?

No major systems language has emerged in over a decade, but over that timethe computing landscape has changed tremendously. There are several trends:

- Computers are enormously quicker but software development is not faster.
- Dependency management is a big part of software development today but the“header files” of languages in the C tradition are antithetical to cleandependency analysis—and fast compilation.
- There is a growing rebellion against cumbersome type systems like those ofJava and C++, pushing people towards dynamically typed languages such asPython and JavaScript.
- Some fundamental concepts such as garbage collection and parallel computationare not well supported by popular systems languages.
- The emergence of multicore computers has generated worry and confusion.

We believe it's worth trying again with a new language, a concurrent,garbage-collected language with fast compilation. Regarding the points above:

- It is possible to compile a large Go program in a few seconds on a single computer.
- Go provides a model for software construction that makes dependencyanalysis easy and avoids much of the overhead of C-style include files andlibraries.
- Go's type system has no hierarchy, so no time is spent defining therelationships between types. Also, although Go has static types the languageattempts to make types feel lighter weight than in typical OO languages.
- Go is fully garbage-collected and provides fundamental support forconcurrent execution and communication.
- By its design, Go proposes an approach for the construction of systemsoftware on multicore machines.

A much more expansive answer to this question is available in the article,[Go at Google:Language Design in the Service of Software Engineering](http://talks.golang.org/2012/splash.article).

### What is the status of the project?

Go became a public open source project on November 10, 2009.After a couple of years of very active design and development, stability was called for andGo 1 was [released](http://blog.golang.org/2012/03/go-version-1-is-released.html)on March 28, 2012.Go 1, which includes a [language specification](http://golang.org/ref/spec),[standard libraries](http://golang.org/pkg/),and [custom tools](http://golang.org/cmd/go/),provides a stable foundation for creating reliable products, projects, and publications.

With that stability established, we are using Go to develop programs, products, and tools rather thanactively changing the language and libraries.In fact, the purpose of Go 1 is to provide [long-term stability](http://golang.org/doc/go1compat.html).Backwards-incompatible changes will not be made to any Go 1 point release.We want to use what we have to learn how a future version of Go might look, rather than to play withthe language underfoot.

Of course, development will continue on Go itself, but the focus will be on performance, reliability,portability and the addition of new functionality such as improved support for internationalization.

There may well be a Go 2 one day, but not for a few years and it will be influenced by what we learn using Go 1 as it is today.

### What is the origin of the name?

“Ogle” would be a good name for a Go debugger.

### What's the origin of the mascot?

The mascot and logo were designed by[Renée French](http://reneefrench.blogspot.com/), who also designed[Glenda](http://plan9.bell-labs.com/plan9/glenda.html),the Plan 9 bunny.The gopher is derived from one she used for an [WFMU](http://wfmu.org/)T-shirt design some years ago.The logo and mascot are covered by the[Creative Commons Attribution 3.0](http://creativecommons.org/licenses/by/3.0/)license.

### What is the history of the project?

Robert Griesemer, Rob Pike and Ken Thompson started sketching thegoals for a new language on the white board on September 21, 2007.Within a few days the goals had settled into a plan to do somethingand a fair idea of what it would be.  Design continued part-time inparallel with unrelated work.  By January 2008, Ken had started workon a compiler with which to explore ideas; it generated C code as itsoutput.  By mid-year the language had become a full-time project andhad settled enough to attempt a production compiler.  In May 2008,Ian Taylor independently started on a GCC front end for Go using thedraft specification.  Russ Cox joined in late 2008 and helped move the languageand libraries from prototype to reality.

Go became a public open source project on November 10, 2009.Many people from the community have contributed ideas, discussions, and code.

### Why are you creating a new language?

Go was born out of frustration with existing languages andenvironments for systems programming.  Programming had become toodifficult and the choice of languages was partly to blame.  One had tochoose either efficient compilation, efficient execution, or ease ofprogramming; all three were not available in the same mainstreamlanguage.  Programmers who could were choosing ease oversafety and efficiency by moving to dynamically typed languages such asPython and JavaScript rather than C++ or, to a lesser extent, Java.

Go is an attempt to combine the ease of programming of an interpreted,dynamically typedlanguage with the efficiency and safety of a statically typed, compiled language.It also aims to be modern, with support for networked and multicorecomputing.  Finally, it is intended to be *fast*: it should takeat most a few seconds to build a large executable on a single computer.To meet these goals required addressing a number oflinguistic issues: an expressive but lightweight type system;concurrency and garbage collection; rigid dependency specification;and so on.  These cannot be addressed well by libraries or tools; a newlanguage was called for.

The article [Go at Google](http://talks.golang.org/2012/splash.article)discusses the background and motivation behind the design of the Go language,as well as providing more detail about many of the answers presented in this FAQ.

### What are Go's ancestors?

Go is mostly in the C family (basic syntax),with significant input from the Pascal/Modula/Oberonfamily (declarations, packages),plus some ideas from languagesinspired by Tony Hoare's CSP,such as Newsqueak and Limbo (concurrency).However, it is a new language across the board.In every respect the language was designed by thinkingabout what programmers do and how to make programming, at least thekind of programming we do, more effective, which means more fun.

### What are the guiding principles in the design?

Programming today involves too much bookkeeping, repetition, andclerical work.  As Dick Gabriel says, “Old programs readlike quiet conversations between a well-spoken research worker and awell-studied mechanical colleague, not as a debate with a compiler.Who'd have guessed sophistication bought such noise?”The sophistication is worthwhile—no one wants to go back tothe old languages—but can it be more quietly achieved?

Go attempts to reduce the amount of typing in both senses of the word.Throughout its design, we have tried to reduce clutter andcomplexity.  There are no forward declarations and no header files;everything is declared exactly once.  Initialization is expressive,automatic, and easy to use.  Syntax is clean and light on keywords.Stuttering (`foo.Foo* myFoo = new(foo.Foo)`) is reduced bysimple type derivation using the `:=`declare-and-initialize construct.  And perhaps most radically, thereis no type hierarchy: types just *are*, they don't have toannounce their relationships.  These simplifications allow Go to beexpressive yet comprehensible without sacrificing, well, sophistication.

Another important principle is to keep the concepts orthogonal.Methods can be implemented for any type; structures represent data whileinterfaces represent abstraction; and so on.  Orthogonality makes iteasier to understand what happens when things combine.

## Usage

###  Is Google using Go internally?

Yes. There are now several Go programs deployed inproduction inside Google.  A public example is the server behind[golang.org](http://golang.org/).It's just the [`godoc`](http://golang.org/cmd/godoc)document server running in a production configuration on[Google App Engine](https://developers.google.com/appengine/).

Other examples include the [Vitess](http://code.google.com/p/vitess/)system for large-scale SQL installations and Google's download server, `dl.google.com`,which delivers Chrome binaries and other large installables such as `apt-get`packages.

### Do Go programs link with C/C++ programs?

There are two Go compiler implementations, `gc`(the `6g` program and friends) and `gccgo`.`Gc` uses a different calling convention and linker and cantherefore only be linked with C programs using the same convention.There is such a C compiler but no C++ compiler.`Gccgo` is a GCC front-end that can, with care, be linked withGCC-compiled C or C++ programs.

The [cgo](http://golang.org/cmd/cgo/) program provides the mechanism for a“foreign function interface” to allow safe calling ofC libraries from Go code. SWIG extends this capability to C++ libraries.

### Does Go support Google's protocol buffers?

A separate open source project provides the necessary compiler plugin and library.It is available at[code.google.com/p/goprotobuf/](http://code.google.com/p/goprotobuf/)

### Can I translate the Go home page into another language?

Absolutely. We encourage developers to make Go Language sites in their own languages.However, if you choose to add the Google logo or branding to your site(it does not appear on [golang.org](http://golang.org/)),you will need to abide by the guidelines at[www.google.com/permissions/guidelines.html](http://www.google.com/permissions/guidelines.html)

## Design

### What's up with Unicode identifiers?

It was important to us to extend the space of identifiers from theconfines of ASCII.  Go's rule—identifier characters must beletters or digits as defined by Unicode—is simple to understandand to implement but has restrictions.  Combining characters areexcluded by design, for instance.Until thereis an agreed external definition of what an identifier might be,plus a definition of canonicalization of identifiers that guaranteesno ambiguity, it seemed better to keep combining characters out ofthe mix.  Thus we have a simple rule that can be expanded laterwithout breaking programs, one that avoids bugs that would surely arisefrom a rule that admits ambiguous identifiers.

On a related note, since an exported identifier must begin with anupper-case letter, identifiers created from “letters”in some languages can, by definition, not be exported.  For now theonly solution is to use something like `X日本語`, whichis clearly unsatisfactory; we are considering other options.  Thecase-for-visibility rule is unlikely to change however; it's oneof our favorite features of Go.

### Why does Go not have feature X?

Every language contains novel features and omits someone's favoritefeature. Go was designed with an eye on felicity of programming, speed ofcompilation, orthogonality of concepts, and the need to support featuressuch as concurrency and garbage collection. Your favorite feature may bemissing because it doesn't fit, because it affects compilation speed orclarity of design, or because it would make the fundamental system modeltoo difficult.

If it bothers you that Go is missing feature X,please forgive us and investigate the features that Go does have. You might find thatthey compensate in interesting ways for the lack of X.

### Why does Go not have generic types?

Generics may well be added at some point.  We don't feel an urgency forthem, although we understand some programmers do.

Generics are convenient but they come at a cost incomplexity in the type system and run-time.  We haven't yet found adesign that gives value proportionate to the complexity, although wecontinue to think about it.  Meanwhile, Go's built-in maps and slices,plus the ability to use the empty interface to construct containers(with explicit unboxing) mean in many cases it is possible to writecode that does what generics would enable, if less smoothly.

This remains an open issue.

### Why does Go not have exceptions?

We believe that coupling exceptions to a controlstructure, as in the `try-catch-finally` idiom, results inconvoluted code.  It also tends to encourage programmers to labeltoo many ordinary errors, such as failing to open a file, asexceptional.

Go takes a different approach.  For plain error handling, Go's multi-valuereturns make it easy to report an error without overloading the return value.[A canonical error type, coupledwith Go's other features](http://golang.org/doc/articles/error_handling.html), makes error handling pleasant but quite differentfrom that in other languages.

Go also has a coupleof built-in functions to signal and recover from truly exceptionalconditions.  The recovery mechanism is executed only as part of afunction's state being torn down after an error, which is sufficientto handle catastrophe but requires no extra control structures and,when used well, can result in clean error-handling code.

See the [Defer, Panic, and Recover](http://golang.org/doc/articles/defer_panic_recover.html) article for details.

### Why does Go not have assertions?

Go doesn't provide assertions. They are undeniably convenient, but ourexperience has been that programmers use them as a crutch to avoid thinkingabout proper error handling and reporting. Proper error handling means thatservers continue operation after non-fatal errors instead of crashing.Proper error reporting means that errors are direct and to the point,saving the programmer from interpreting a large crash trace. Preciseerrors are particularly important when the programmer seeing the errors isnot familiar with the code.

We understand that this is a point of contention. There are many things inthe Go language and libraries that differ from modern practices, simplybecause we feel it's sometimes worth trying a different approach.

### Why build concurrency on the ideas of CSP?

Concurrency and multi-threaded programming have a reputationfor difficulty.  We believe this is due partly to complexdesigns such as pthreads and partly to overemphasis on low-level detailssuch as mutexes, condition variables, and memory barriers.Higher-level interfaces enable much simpler code, even if there are stillmutexes and such under the covers.

One of the most successful models for providing high-level linguistic supportfor concurrency comes from Hoare's Communicating Sequential Processes, or CSP.Occam and Erlang are two well known languages that stem from CSP.Go's concurrency primitives derive from a different part of the family treewhose main contribution is the powerful notion of channels as first class objects.Experience with several earlier languages has shown that the CSP modelfits well into a procedural language framework.

### Why goroutines instead of threads?

Goroutines are part of making concurrency easy to use.  The idea, which hasbeen around for a while, is to multiplex independently executingfunctions—coroutines—onto a set of threads.When a coroutine blocks, such as by calling a blocking system call,the run-time automatically moves other coroutines on the same operatingsystem thread to a different, runnable thread so they won't be blocked.The programmer sees none of this, which is the point.The result, which we call goroutines, can be very cheap: they have littleoverhead beyond the memory for the stack, which is just a few kilobytes.

To make the stacks small, Go's run-time uses resizable, bounded stacks.  A newlyminted goroutine is given a few kilobytes, which is almost always enough.When it isn't, the run-time grows (and shrinks) the memory for storingthe stack automatically, allowing many goroutines to live in a modestamount of memory.The CPU overhead averages about three cheap instructions per function call.It is practical to create hundreds of thousands of goroutines in the sameaddress space.If goroutines were just threads, system resources wouldrun out at a much smaller number.

### Why are map operations not defined to be atomic?

After long discussion it was decided that the typical use of maps did not requiresafe access from multiple goroutines, and in those cases where it did, the map wasprobably part of some larger data structure or computation that was alreadysynchronized.  Therefore requiring that all map operations grab a mutex would slowdown most programs and add safety to few.  This was not an easy decision,however, since it means uncontrolled map access can crash the program.

The language does not preclude atomic map updates.  When required, suchas when hosting an untrusted program, the implementation could interlockmap access.

### Will you accept my language change?

People often suggest improvements to the language—the[mailing list](http://groups.google.com/group/golang-nuts)contains a rich history of such discussions—but very few of these changes havebeen accepted.

Although Go is an open source project, the language and libraries are protectedby a [compatibility promise](http://golang.org/doc/go1compat.html) that preventschanges that break existing programs.If your proposal violates the Go 1 specification we cannot even entertain theidea, regardless of its merit.A future major release of Go may be incompatible with Go 1, but we're not readyto start talking about what that might be.

Even if your proposal is compatible with the Go 1 spec, it mightnot be in the spirit of Go's design goals.The article *Goat Google: Language Design in the Service of Software Engineering*explains Go's origins and the motivation behind its design.

## Types

### Is Go an object-oriented language?

Yes and no. Although Go has types and methods and allows anobject-oriented style of programming, there is no type hierarchy.The concept of “interface” in Go provides a different approach thatwe believe is easy to use and in some ways more general. There arealso ways to embed types in other types to provide somethinganalogous—but not identical—to subclassing.Moreover, methods in Go are more general than in C++ or Java:they can be defined for any sort of data, even built-in types suchas plain, “unboxed” integers.They are not restricted to structs (classes).

Also, the lack of type hierarchy makes “objects” in Go feel much morelightweight than in languages such as C++ or Java.

### How do I get dynamic dispatch of methods?

The only way to have dynamically dispatched methods is through aninterface. Methods on a struct or any other concrete type are always resolved statically.

### Why is there no type inheritance?

Object-oriented programming, at least in the best-known languages,involves too much discussion of the relationships between types,relationships that often could be derived automatically.  Go takes adifferent approach.

Rather than requiring the programmer to declare ahead of time that twotypes are related, in Go a type automatically satisfies any interfacethat specifies a subset of its methods.  Besides reducing thebookkeeping, this approach has real advantages.  Types can satisfymany interfaces at once, without the complexities of traditionalmultiple inheritance.Interfaces can be very lightweight—an interface withone or even zero methods can express a useful concept.Interfaces can be added after the fact if a new idea comes alongor for testing—without annotating the original types.Because there are no explicit relationships between typesand interfaces, there is no type hierarchy to manage or discuss.

It's possible to use these ideas to construct something analogous totype-safe Unix pipes.  For instance, see how `fmt.Fprintf`enables formatted printing to any output, not just a file, or how the`bufio` package can be completely separate from file I/O,or how the `image` packages generate compressedimage files.  All these ideas stem from a single interface(`io.Writer`) representing a single method(`Write`).  And that's only scratching the surface.Go's interfaces have a profound influence on how programs are structured.

It takes some getting used to but this implicit style of typedependency is one of the most productive things about Go.

### Why is `len` a function and not a method?

We debated this issue but decidedimplementing `len` and friends as functions was fine in practice anddidn't complicate questions about the interface (in the Go type sense)of basic types.

### Why does Go not support overloading of methods and operators?

Method dispatch is simplified if it doesn't need to do type matching as well.Experience with other languages told us that having a variety ofmethods with the same name but different signatures was occasionally usefulbut that it could also be confusing and fragile in practice.  Matching only by nameand requiring consistency in the types was a major simplifying decisionin Go's type system.

Regarding operator overloading, it seems more a convenience than an absoluterequirement.  Again, things are simpler without it.

### Why doesn't Go have "implements" declarations?

A Go type satisfies an interface by implementing the methods of that interface,nothing more.  This property allows interfaces to be defined and used withouthaving to modify existing code.  It enables a kind of structural typing thatpromotes separation of concerns and improves code re-use, and makes it easierto build on patterns that emerge as the code develops.The semantics of interfaces is one of the main reasons for Go's nimble,lightweight feel.

See the [question on type inheritance](http://golang.org/doc/faq#inheritance) for more detail.

### How can I guarantee my type satisfies an interface?

You can ask the compiler to check that the type `T` implements theinterface `I` by attempting an assignment:

```
type T struct{}
var _ I = T{}   // Verify that T implements I.

```

If `T` doesn't implement `I`, the mistake will be caughtat compile time.

If you wish the users of an interface to explicitly declare that they implementit, you can add a method with a descriptive name to the interface's method set.For example:

```
type Fooer interface {
    Foo()
    ImplementsFooer()
}

```

A type must then implement the `ImplementsFooer` method to be a`Fooer`, clearly documenting the fact and announcing it in[godoc](http://golang.org/cmd/godoc/)'s output.

```
type Bar struct{}
func (b Bar) ImplementsFooer() {}
func (b Bar) Foo() {}

```

Most code doesn't make use of such constraints, since they limit the utility ofthe interface idea. Sometimes, though, they're necessary to resolve ambiguitiesamong similar interfaces.

### Why doesn't type T satisfy the Equal interface?

Consider this simple interface to represent an object that can compareitself with another value:

```
type Equaler interface {
    Equal(Equaler) bool
}

```

and this type, `T`:

```
type T int
func (t T) Equal(u T) bool { return t == u } // does not satisfy Equaler

```

Unlike the analogous situation in some polymorphic type systems,`T` does not implement `Equaler`.The argument type of `T.Equal` is `T`,not literally the required type `Equaler`.

In Go, the type system does not promote the argument of`Equal`; that is the programmer's responsibility, asillustrated by the type `T2`, which does implement`Equaler`:

```
type T2 int
func (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // satisfies Equaler

```

Even this isn't like other type systems, though, because in Go *any*type that satisfies `Equaler` could be passed as theargument to `T2.Equal`, and at run time we mustcheck that the argument is of type `T2`.Some languages arrange to make that guarantee at compile time.

A related example goes the other way:

```
type Opener interface {
   Open() Reader
}

func (t T3) Open() *os.File

```

In Go, `T3` does not satisfy `Opener`,although it might in another language.

While it is true that Go's type system does less for the programmerin such cases, the lack of subtyping makes the rules aboutinterface satisfaction very easy to state: are the function's namesand signatures exactly those of the interface?Go's rule is also easy to implement efficiently.We feel these benefits offset the lack ofautomatic type promotion. Should Go one day adopt some form of generictyping, we expect there would be a way to express the idea of theseexamples and also have them be statically checked.

### Can I convert a []T to an []interface{}?

Not directly, because they do not have the same representation in memory.It is necessary to copy the elements individually to the destinationslice. This example converts a slice of `int` to a slice of`interface{}`:

```
t := []int{1, 2, 3, 4}
s := make([]interface{}, len(t))
for i, v := range t {
    s[i] = v
}

```

### Why is my nil error value not equal to nil?

Under the covers, interfaces are implemented as two elements, a type and a value.The value, called the interface's dynamic value,is an arbitrary concrete value and the type is that of the value.For the `int` value 3, an interface value contains,schematically, (`int`, `3`).

An interface value is `nil` only if the inner value and type are both unset,(`nil`, `nil`).In particular, a `nil` interface will always hold a `nil` type.If we store a pointer of type `*int` insidean interface value, the inner type will be `*int` regardless of the value of the pointer:(`*int`, `nil`).Such an interface value will therefore be non-`nil`*even when the pointer inside is* `nil`.

This situation can be confusing, and often arises when a `nil` value isstored inside an interface value such as an `error` return:

```
func returnsError() error {
	var p *MyError = nil
	if bad() {
		p = ErrBad
	}
	return p // Will always return a non-nil error.
}

```

If all goes well, the function returns a `nil` `p`,so the return value is an `error` interfacevalue holding (`*MyError`, `nil`).This means that if the caller compares the returned error to `nil`,it will always look as if there was an error even if nothing bad happened.To return a proper `nil` `error` to the caller,the function must return an explicit `nil`:

```
func returnsError() error {
	if bad() {
		return ErrBad
	}
	return nil
}

```

It's a good idea for functionsthat return errors always to use the `error` type intheir signature (as we did above) rather than a concrete type suchas `*MyError`, to help guarantee the error iscreated correctly. As an example,[`os.Open`](http://golang.org/pkg/os/#Open)returns an `error` even though, if not `nil`,it's always of concrete type[`*os.PathError`](http://golang.org/pkg/os/#PathError).

Similar situations to those described here can arise whenever interfaces are used.Just keep in mind that if any concrete valuehas been stored in the interface, the interface will not be `nil`.For more information, see[The Laws of Reflection](http://golang.org/doc/articles/laws_of_reflection.html).

### Why are there no untagged unions, as in C?

Untagged unions would violate Go's memory safetyguarantees.

### Why does Go not have variant types?

Variant types, also known as algebraic types, provide a way to specifythat a value might take one of a set of other types, but only thosetypes. A common example in systems programming would specify that anerror is, say, a network error, a security error or an applicationerror and allow the caller to discriminate the source of the problemby examining the type of the error. Another example is a syntax treein which each node can be a different type: declaration, statement,assignment and so on.

We considered adding variant types to Go, but after discussiondecided to leave them out because they overlap in confusing wayswith interfaces. What would happen if the elements of a variant typewere themselves interfaces?

Also, some of what variant types address is already covered by thelanguage. The error example is easy to express using an interfacevalue to hold the error and a type switch to discriminate cases.  Thesyntax tree example is also doable, although not as elegantly.

## Values

### Why does Go not provide implicit numeric conversions?

The convenience of automatic conversion between numeric types in C isoutweighed by the confusion it causes.  When is an expression unsigned?How big is the value?  Does it overflow?  Is the result portable, independentof the machine on which it executes?It also complicates the compiler; “the usual arithmetic conversions”are not easy to implement and inconsistent across architectures.For reasons of portability, we decided to make things clear and straightforwardat the cost of some explicit conversions in the code.The definition of constants in Go—arbitrary precision values freeof signedness and size annotations—ameliorates matters considerably,though.

A related detail is that, unlike in C, `int` and `int64`are distinct types even if `int` is a 64-bit type.  The `int`type is generic; if you care about how many bits an integer holds, Goencourages you to be explicit.

A blog post, title [Constants](http://blog.golang.org/constants),explores this topic in more detail.

### Why are maps built in?

The same reason strings are: they are such a powerful and important datastructure that providing one excellent implementation with syntactic supportmakes programming more pleasant.  We believe that Go's implementation of mapsis strong enough that it will serve for the vast majority of uses.If a specific application can benefit from a custom implementation, it's possibleto write one but it will not be as convenient syntactically; this seems a reasonable tradeoff.

### Why don't maps allow slices as keys?

Map lookup requires an equality operator, which slices do not implement.They don't implement equality because equality is not well defined on such types;there are multiple considerations involving shallow vs. deep comparison, pointer vs.value comparison, how to deal with recursive types, and so on.We may revisit this issue—and implementing equality for sliceswill not invalidate any existing programs—but without a clear idea of whatequality of slices should mean, it was simpler to leave it out for now.

In Go 1, unlike prior releases, equality is defined for structs and arrays, so suchtypes can be used as map keys. Slices still do not have a definition of equality, though.

### Why are maps, slices, and channels references while arrays are values?

There's a lot of history on that topic.  Early on, maps and channelswere syntactically pointers and it was impossible to declare or use anon-pointer instance.  Also, we struggled with how arrays should work.Eventually we decided that the strict separation of pointers andvalues made the language harder to use.  Changing thesetypes to act as references to the associated, shared data structures resolvedthese issues. This change added some regrettable complexity to thelanguage but had a large effect on usability: Go became a moreproductive, comfortable language when it was introduced.

## Writing Code

### How are libraries documented?

There is a program, `godoc`, written in Go, that extractspackage documentation from the source code. It can be used on thecommand line or on the web. An instance is running at[golang.org/pkg/](http://golang.org/pkg/).In fact, `godoc` implements the full site at[golang.org/](http://golang.org/).

### Is there a Go programming style guide?

Eventually, there may be a small number of rules to guide thingslike naming, layout, and file organization.The document [Effective Go](http://golang.org/doc/effective_go.html)contains some style advice.More directly, the program `gofmt` is a pretty-printerwhose purpose is to enforce layout rules; it replaces the usualcompendium of do's and don'ts that allows interpretation.All the Go code in the repository has been run through `gofmt`.

The document titled[Go Code Review Comments](http://golang.org/s/comments)is a collection of very short essays about details of Go idiom that are oftenmissed by programmers.It is a handy reference for people doing code reviews for Go projects.

### How do I submit patches to the Go libraries?

The library sources are in the `src` directory of the repository.If you want to make a significant change, please discuss on the mailing list before embarking.

See the document[Contributing to the Go project](http://golang.org/doc/contribute.html)for more information about how to proceed.

### Why does "go get" use HTTPS when cloning a repository?

Companies often permit outgoing traffic only on the standard TCP ports 80 (HTTP)and 443 (HTTPS), blocking outgoing traffic on other ports, including TCP port 9418 (git) and TCP port 22 (SSH).When using HTTPS instead of HTTP, `git` enforces certificate validation bydefault, providing protection against man-in-the-middle, eavesdropping and tampering attacks.The `go get` command therefore uses HTTPS for safety.

If you use `git` and prefer to push changes through SSH using your existing key it's easy to work around this. For GitHub, try one of these solutions:

- Manually clone the repository in the expected package directory:

  ```
  $ cd $GOPATH/src/github.com/username
  $ git clone git@github.com:username/package.git

  ```

- Force 

  ```
  git push
  ```

   to use the 

  ```
  SSH
  ```

   protocol by appendingthese two lines to 

  ```
  ~/.gitconfig
  ```

  :

  ```
  [url "git@github.com:"]
  	pushInsteadOf = https://github.com/

  ```

### How should I manage package versions using "go get"?

"Go get" does not have any explicit concept of package versions.Versioning is a source of significant complexity, especially in large code bases,and we are unaware of any approach that works well at scale in a large enoughvariety of situations to be appropriate to force on all Go users.What "go get" and the larger Go toolchain do provide is isolation ofpackages with different import paths.For example, the standard library's `html/template` and `text/template`coexist even though both are "package template".This observation leads to some advice for package authors and package users.

Packages intended for public use should try to maintain backwards compatibility as they evolve.The [Go 1 compatibility guidelines](http://golang.org/doc/go1compat.html) are a good reference here:don't remove exported names, encourage tagged composite literals, and so on.If different functionality is required, add a new name instead of changing an old one.If a complete break is required, create a new package with a new import path.

If you're using an externally supplied package and worry that it might change inunexpected ways, the simplest solution is to copy it to your local repository.(This is the approach Google takes internally.)Store the copy under a new import path that identifies it as a local copy.For example, you might copy "original.com/pkg" to "you.com/external/original.com/pkg".Keith Rarick's [goven](https://github.com/kr/goven) is one tool to help automate this process.

## Pointers and Allocation

### When are function parameters passed by value?

As in all languages in the C family, everything in Go is passed by value.That is, a function always gets a copy of thething being passed, as if there were an assignment statement assigning thevalue to the parameter.  For instance, passing an `int` valueto a function makes a copy of the `int`, and passing a pointervalue makes a copy of the pointer, but not the data it points to.(See the next section for a discussion of how this affects method receivers.)

Map and slice values behave like pointers: they are descriptors thatcontain pointers to the underlying map or slice data.  Copying a map orslice value doesn't copy the data it points to.  Copying an interface valuemakes a copy of the thing stored in the interface value.  If the interfacevalue holds a struct, copying the interface value makes a copy of thestruct.  If the interface value holds a pointer, copying the interface valuemakes a copy of the pointer, but again not the data it points to.

### When should I use a pointer to an interface?

Almost never. Pointers to interface values arise only in rare, tricky situations involvingdisguising an interface value's type for delayed evaluation.

It is however a common mistake to pass a pointer to an interface valueto a function expecting an interface. The compiler will complain about thiserror but the situation can still be confusing, because sometimes a[pointeris necessary to satisfy an interface](http://golang.org/doc/faq#different_method_sets).The insight is that although a pointer to a concrete type can satisfyan interface, with one exception *a pointer to an interface can never satisfy an interface*.

Consider the variable declaration,

```
var w io.Writer

```

The printing function `fmt.Fprintf` takes as its first argumenta value that satisfies `io.Writer`—something that implementsthe canonical `Write` method. Thus we can write

```
fmt.Fprintf(w, "hello, world\n")

```

If however we pass the address of `w`, the program will not compile.

```
fmt.Fprintf(&w, "hello, world\n") // Compile-time error.

```

The one exception is that any value, even a pointer to an interface, can be assigned toa variable of empty interface type (`interface{}`).Even so, it's almost certainly a mistake if the value is a pointer to an interface;the result can be confusing.

### Should I define methods on values or pointers?

```
func (s *MyStruct) pointerMethod() { } // method on pointer
func (s MyStruct)  valueMethod()   { } // method on value

```

For programmers unaccustomed to pointers, the distinction between thesetwo examples can be confusing, but the situation is actually very simple.When defining a method on a type, the receiver (`s` in the aboveexamples) behaves exactly as if it were an argument to the method.Whether to define the receiver as a value or as a pointer is the samequestion, then, as whether a function argument should be a value ora pointer.There are several considerations.

First, and most important, does the method need to modify thereceiver?If it does, the receiver *must* be a pointer.(Slices and maps act as references, so their story is a littlemore subtle, but for instance to change the length of a slicein a method the receiver must still be a pointer.)In the examples above, if `pointerMethod` modifiesthe fields of `s`,the caller will see those changes, but `valueMethod`is called with a copy of the caller's argument (that's the definitionof passing a value), so changes it makes will be invisible to the caller.

By the way, pointer receivers are identical to the situation in Java,although in Java the pointers are hidden under the covers; it's Go'svalue receivers that are unusual.

Second is the consideration of efficiency. If the receiver is large,a big `struct` for instance, it will be much cheaper touse a pointer receiver.

Next is consistency. If some of the methods of the type must havepointer receivers, the rest should too, so the method set isconsistent regardless of how the type is used.See the section on [method sets](http://golang.org/doc/faq#different_method_sets)for details.

For types such as basic types, slices, and small `structs`,a value receiver is very cheap so unless the semantics of the methodrequires a pointer, a value receiver is efficient and clear.

### What's the difference between new and make?

In short: `new` allocates memory, `make` initializesthe slice, map, and channel types.

See the [relevant sectionof Effective Go](http://golang.org/doc/effective_go.html#allocation_new) for more details.

### What is the size of an `int` on a 64 bit machine?

The sizes of `int` and `uint` are implementation-specificbut the same as each other on a given platform.For portability, code that relies on a particularsize of value should use an explicitly sized type, like `int64`.Prior to Go 1.1, the 64-bit Go compilers (both gc and gccgo) useda 32-bit representation for `int`. As of Go 1.1 they usea 64-bit representation.On the other hand, floating-point scalars and complexnumbers are always sized: `float32`, `complex64`,etc., because programmers should be aware of precision when usingfloating-point numbers.The default size of a floating-point constant is `float64`.

### How do I know whether a variable is allocated on the heap or the stack?

From a correctness standpoint, you don't need to know.Each variable in Go exists as long as there are references to it.The storage location chosen by the implementation is irrelevant to thesemantics of the language.

The storage location does have an effect on writing efficient programs.When possible, the Go compilers will allocate variables that arelocal to a function in that function's stack frame.  However, if thecompiler cannot prove that the variable is not referenced after thefunction returns, then the compiler must allocate the variable on thegarbage-collected heap to avoid dangling pointer errors.Also, if a local variable is very large, it might make more senseto store it on the heap rather than the stack.

In the current compilers, if a variable has its address taken, that variableis a candidate for allocation on the heap. However, a basic *escapeanalysis* recognizes some cases when such variables will notlive past the return from the function and can reside on the stack.

### Why does my Go process use so much virtual memory?

The Go memory allocator reserves a large region of virtual memory as an arenafor allocations. This virtual memory is local to the specific Go process; thereservation does not deprive other processes of memory.

To find the amount of actual memory allocated to a Go process, use the Unix`top` command and consult the `RES` (Linux) or`RSIZE` (Mac OS X) columns.

## Concurrency

### What operations are atomic? What about mutexes?

We haven't fully defined it all yet, but some details about atomicity areavailable in the [Go Memory Model specification](http://golang.org/ref/mem).

Regarding mutexes, the [sync](http://golang.org/pkg/sync)package implements them, but we hope Go programming style willencourage people to try higher-level techniques. In particular, considerstructuring your program so that only one goroutine at a time is everresponsible for a particular piece of data.

Do not communicate by sharing memory. Instead, share memory by communicating.

See the [Share Memory By Communicating](http://golang.org/doc/codewalk/sharemem/) code walk and its [associated article](http://blog.golang.org/2010/07/share-memory-by-communicating.html) for a detailed discussion of this concept.

### Why doesn't my multi-goroutine program use multiple CPUs?

You must set the `GOMAXPROCS` shell environment variableor use the similarly-named [`function`](http://golang.org/pkg/runtime/#GOMAXPROCS)of the runtime package to allow therun-time support to utilize more than one OS thread.

Programs that perform parallel computation should benefit from an increase in`GOMAXPROCS`.However, be aware that[concurrencyis not parallelism](http://blog.golang.org/2013/01/concurrency-is-not-parallelism.html).

### Why does using `GOMAXPROCS` > 1 sometimes make my programslower?

It depends on the nature of your program.Problems that are intrinsically sequential cannot be sped up by addingmore goroutines.Concurrency only becomes parallelism when the problem isintrinsically parallel.

In practical terms, programs that spend more timecommunicating on channels than doing computationwill experience performance degradation when usingmultiple OS threads.This is because sending data between threads involves switchingcontexts, which has significant cost.For instance, the [prime sieve example](http://golang.org/ref/spec#An_example_package)from the Go specification has no significant parallelism although it launches manygoroutines; increasing `GOMAXPROCS` is more likely to slow it down thanto speed it up.

Go's goroutine scheduler is not as good as it needs to be. In the future, itshould recognize such cases and optimize its use of OS threads. For now,`GOMAXPROCS` should be set on a per-application basis.

For more detail on this topic see the talk entitled,[Concurrencyis not Parallelism](http://blog.golang.org/2013/01/concurrency-is-not-parallelism.html).

## Functions and Methods

### Why do T and *T have different method sets?

From the [Go Spec](http://golang.org/ref/spec#Types):

> The method set of any other named type `T` consists of all methodswith receiver type `T`. The method set of the corresponding pointertype `*T` is the set of all methods with receiver `*T` or`T` (that is, it also contains the method set of `T`).

If an interface value contains a pointer `*T`,a method call can obtain a value by dereferencing the pointer,but if an interface value contains a value `T`,there is no useful way for a method call to obtain a pointer.

Even in cases where the compiler could take the address of a valueto pass to the method, if the method modifies the value the changeswill be lost in the caller.As a common example, this code:

```
var buf bytes.Buffer
io.Copy(buf, os.Stdin)

```

would copy standard input into a *copy* of `buf`,not into `buf` itself.This is almost never the desired behavior.

### What happens with closures running as goroutines?

Some confusion may arise when using closures with concurrency.Consider the following program:

```
func main() {
    done := make(chan bool)

    values := []string{"a", "b", "c"}
    for _, v := range values {
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }

    // wait for all goroutines to complete before exiting
    for _ = range values {
        <-done
    }
}

```

One might mistakenly expect to see `a, b, c` as the output.What you'll probably see instead is `c, c, c`.  This is becauseeach iteration of the loop uses the same instance of the variable `v`, soeach closure shares that single variable. When the closure runs, it prints thevalue of `v` at the time `fmt.Println` is executed,but `v` may have been modified since the goroutine was launched.To help detect this and other problems before they happen, run[`go vet`](http://golang.org/cmd/go/#hdr-Run_go_tool_vet_on_packages).

To bind the current value of `v` to each closure as it is launched, onemust modify the inner loop to create a new variable each iteration.One way is to pass the variable as an argument to the closure:

```
    for _, v := range values {
        go func(u string) {
            fmt.Println(u)
            done <- true
        }(v)
    }

```

In this example, the value of `v` is passed as an argument to theanonymous function. That value is then accessible inside the function asthe variable `u`.

Even easier is just to create a new variable, using a declaration style that mayseem odd but works fine in Go:

```
    for _, v := range values {
        v := v // create a new 'v'.
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }

```

## Control flow

### Does Go have the `?:` operator?

There is no ternary form in Go. You may use the following to achieve the sameresult:

```
if expr {
    n = trueVal
} else {
    n = falseVal
}

```

## Packages and Testing

### How do I create a multifile package?

Put all the source files for the package in a directory by themselves.Source files can refer to items from different files at will; there isno need for forward declarations or a header file.

Other than being split into multiple files, the package will compile and testjust like a single-file package.

### How do I write a unit test?

Create a new file ending in `_test.go` in the same directoryas your package sources. Inside that file, `import "testing"`and write functions of the form

```
func TestFoo(t *testing.T) {
    ...
}

```

Run `go test` in that directory.That script finds the `Test` functions,builds a test binary, and runs it.

See the [How to Write Go Code](http://golang.org/doc/code.html) document,the [`testing`](http://golang.org/pkg/testing/) packageand the [`go test`](http://golang.org/cmd/go/#hdr-Test_packages) subcommand for more details.

### Where is my favorite helper function for testing?

Go's standard [`testing`](http://golang.org/pkg/testing/) package makes it easy to write unit tests, but it lacksfeatures provided in other language's testing frameworks such as assertion functions.An [earlier section](http://golang.org/doc/faq#assertions) of this document explained why Godoesn't have assertions, andthe same arguments apply to the use of `assert` in tests.Proper error handling means letting other tests run after one has failed, sothat the person debugging the failure gets a complete picture of what iswrong. It is more useful for a test to report that`isPrime` gives the wrong answer for 2, 3, 5, and 7 (or for2, 4, 8, and 16) than to report that `isPrime` gives the wronganswer for 2 and therefore no more tests were run. The programmer whotriggers the test failure may not be familiar with the code that fails.Time invested writing a good error message now pays off later when thetest breaks.

A related point is that testing frameworks tend to develop into mini-languagesof their own, with conditionals and controls and printing mechanisms,but Go already has all those capabilities; why recreate them?We'd rather write tests in Go; it's one fewer language to learn and theapproach keeps the tests straightforward and easy to understand.

If the amount of extra code required to writegood errors seems repetitive and overwhelming, the test might work better iftable-driven, iterating over a list of inputs and outputs definedin a data structure (Go has excellent support for data structure literals).The work to write a good test and good error messages will then be amortized over manytest cases. The standard Go library is full of illustrative examples, such as in[the formatting tests for the `fmt` package](http://golang.org/src/fmt/fmt_test.go).

## Implementation

### What compiler technology is used to build the compilers?

`Gccgo` has a front end written in C++, with a recursive descent parser coupled to thestandard GCC back end. `Gc` is written in C using`yacc`/`bison` for the parser.Although it's a new program, it fits in the Plan 9 C compiler suite(<http://plan9.bell-labs.com/sys/doc/compiler.html>)and uses a variant of the Plan 9 loader to generate ELF/Mach-O/PE binaries.

We considered using LLVM for `gc` but we felt it was too large andslow to meet our performance goals.

We also considered writing `gc`, the original Go compiler, in Go itself butelected not to do so because of the difficulties of bootstrapping andespecially of open source distribution—you'd need a Go compiler toset up a Go environment. `Gccgo`, which came later, makes it possible toconsider writing a compiler in Go.A plan to do that by machine translation of the existing compiler is under development.[A separate document](http://golang.org/s/go13compiler)explains the reason for this approach.

That plan aside,Go is afine language in which to implement a self-hosting compiler: a native lexer andparser are already available in the [`go`](http://golang.org/pkg/go/) packageand a separate type checking[package](http://godoc.org/golang.org/x/tools/go/types)has also been written.

### How is the run-time support implemented?

Again due to bootstrapping issues, the run-time code was originally written mostly in C (with atiny bit of assembler) although much of it has been translated to Go since thenand one day all of it might be (except for the assembler bits).`Gccgo`'s run-time support uses `glibc`.`Gc` uses a custom C library to keep the footprint undercontrol; it iscompiled with a version of the Plan 9 C compiler that supportsresizable stacks for goroutines.The `gccgo` compiler implements these on Linux only,using a technique called segmented stacks,supported by recent modifications to the gold linker.

### Why is my trivial program such a large binary?

The linkers in the gc tool chain (`5l`, `6l`, and `8l`)do static linking.  All Go binaries therefore include the Gorun-time, along with the run-time type information necessary to support dynamictype checks, reflection, and even panic-time stack traces.

A simple C "hello, world" program compiled and linked statically using gccon Linux is around 750 kB,including an implementation of `printf`.An equivalent Go program using `fmt.Printf`is around 1.9 MB, butthat includes more powerful run-time support and type information.

### Can I stop these complaints about my unused variable/import?

The presence of an unused variable may indicate a bug, whileunused imports just slow down compilation,an effect that can become substantial as a program accumulatescode and programmers over time.For these reasons, Go refuses to compile programs with unusedvariables or imports,trading short-term convenience for long-term build speed andprogram clarity.

Still, when developing code, it's common to create these situationstemporarily and it can be annoying to have to edit them out before theprogram will compile.

Some have asked for a compiler option to turn those checks offor at least reduce them to warnings.Such an option has not been added, though,because compiler options should not affect the semantics of thelanguage and because the Go compiler does not report warnings, onlyerrors that prevent compilation.

There are two reasons for having no warnings.  First, if it's worthcomplaining about, it's worth fixing in the code.  (And if it's notworth fixing, it's not worth mentioning.) Second, having the compilergenerate warnings encourages the implementation to warn about weakcases that can make compilation noisy, masking real errors that*should* be fixed.

It's easy to address the situation, though.  Use the blank identifierto let unused things persist while you're developing.

```
import "unused"

// This declaration marks the import as used by referencing an
// item from the package.
var _ = unused.Item  // TODO: Delete before committing!

func main() {
    debugData := debug.Profile()
    _ = debugData // Used only during debugging.
    ....
}

```

Nowadays, most Go programmers use a tool,[goimports](http://godoc.org/golang.org/x/tools/cmd/goimports),which automatically rewrites a Go source file to have the correct imports,eliminating the unused imports issue in practice.This program is easily connected to most editors to run automatically when a Go source file is written.

## Performance

### Why does Go perform badly on benchmark X?

One of Go's design goals is to approach the performance of C for comparableprograms, yet on some benchmarks it does quite poorly, including severalin [test/bench/shootout](http://golang.org/test/bench/shootout/). The slowest depend on librariesfor which versions of comparable performance are not available in Go.For instance, [pidigits.go](http://golang.org/test/bench/shootout/pidigits.go)depends on a multi-precision math package, and the Cversions, unlike Go's, use [GMP](http://gmplib.org/) (which iswritten in optimized assembler).Benchmarks that depend on regular expressions([regex-dna.go](http://golang.org/test/bench/shootout/regex-dna.go), for instance) areessentially comparing Go's native [regexp package](http://golang.org/pkg/regexp) tomature, highly optimized regular expression libraries like PCRE.

Benchmark games are won by extensive tuning and the Go versions of mostof the benchmarks need attention.  If you measure comparable Cand Go programs([reverse-complement.go](http://golang.org/test/bench/shootout/reverse-complement.go) is one example), you'll see the twolanguages are much closer in raw performance than this suite wouldindicate.

Still, there is room for improvement. The compilers are good but could bebetter, many libraries need major performance work, and the garbage collectorisn't fast enough yet. (Even if it were, taking care not to generate unnecessarygarbage can have a huge effect.)

In any case, Go can often be very competitive.There has been significant improvement in the performance of many programsas the language and tools have developed.See the blog post about[profilingGo programs](http://blog.golang.org/2011/06/profiling-go-programs.html) for an informative example.

## Changes from C

### Why is the syntax so different from C?

Other than declaration syntax, the differences are not major and stemfrom two desires.  First, the syntax should feel light, without toomany mandatory keywords, repetition, or arcana.  Second, the languagehas been designed to be easy to analyzeand can be parsed without a symbol table.  This makes it much easierto build tools such as debuggers, dependency analyzers, automateddocumentation extractors, IDE plug-ins, and so on.  C and itsdescendants are notoriously difficult in this regard.

### Why are declarations backwards?

They're only backwards if you're used to C. In C, the notion is that avariable is declared like an expression denoting its type, which is anice idea, but the type and expression grammars don't mix very well andthe results can be confusing; consider function pointers.  Go mostlyseparates expression and type syntax and that simplifies things (usingprefix `*` for pointers is an exception that proves the rule).  In C,the declaration

```
    int* a, b;

```

declares `a` to be a pointer but not `b`; in Go

```
    var a, b *int

```

declares both to be pointers.  This is clearer and more regular.Also, the `:=` short declaration form argues that a full variabledeclaration should present the same order as `:=` so

```
    var a uint64 = 1

```

has the same effect as

```
    a := uint64(1)

```

Parsing is also simplified by having a distinct grammar for types thatis not just the expression grammar; keywords such as `func`and `chan` keep things clear.

See the article about[Go's Declaration Syntax](http://golang.org/doc/articles/gos_declaration_syntax.html)for more details.

### Why is there no pointer arithmetic?

Safety.  Without pointer arithmetic it's possible to create alanguage that can never derive an illegal address that succeedsincorrectly.  Compiler and hardware technology have advanced to thepoint where a loop using array indices can be as efficient as a loopusing pointer arithmetic.  Also, the lack of pointer arithmetic cansimplify the implementation of the garbage collector.

### Why are `++` and `--` statements and not expressions?  And why postfix, not prefix?

Without pointer arithmetic, the convenience value of pre- and postfixincrement operators drops.  By removing them from the expressionhierarchy altogether, expression syntax is simplified and the messyissues around order of evaluation of `++` and `--`(consider `f(i++)` and `p[i] = q[++i]`)are eliminated as well.  The simplification issignificant.  As for postfix vs. prefix, either would work fine butthe postfix version is more traditional; insistence on prefix arosewith the STL, a library for a language whose name contains, ironically, apostfix increment.

### Why are there braces but no semicolons? And why can't I put the openingbrace on the next line?

Go uses brace brackets for statement grouping, a syntax familiar toprogrammers who have worked with any language in the C family.Semicolons, however, are for parsers, not for people, and we wanted toeliminate them as much as possible.  To achieve this goal, Go borrowsa trick from BCPL: the semicolons that separate statements are in theformal grammar but are injected automatically, without lookahead, bythe lexer at the end of any line that could be the end of a statement.This works very well in practice but has the effect that it forces abrace style.  For instance, the opening brace of a function cannotappear on a line by itself.

Some have argued that the lexer should do lookahead to permit thebrace to live on the next line.  We disagree.  Since Go code is meantto be formatted automatically by[`gofmt`](http://golang.org/cmd/gofmt/),*some* style must be chosen.  That style may differ from whatyou've used in C or Java, but Go is a new language and`gofmt`'s style is as good as any other.  Moreimportant—much more important—the advantages of a single,programmatically mandated format for all Go programs greatly outweighany perceived disadvantages of the particular style.Note too that Go's style means that an interactive implementation ofGo can use the standard syntax one line at a time without special rules.

### Why do garbage collection?  Won't it be too expensive?

One of the biggest sources of bookkeeping in systems programs ismemory management.  We feel it's critical to eliminate thatprogrammer overhead, and advances in garbage collectiontechnology in the last few years give us confidence that we canimplement it with low enough overhead and no significantlatency.

Another point is that a large part of the difficulty of concurrentand multi-threaded programming is memory management;as objects get passed among threads it becomes cumbersometo guarantee they become freed safely.Automatic garbage collection makes concurrent code far easier to write.Of course, implementing garbage collection in a concurrent environment isitself a challenge, but meeting it once rather than in everyprogram helps everyone.

Finally, concurrency aside, garbage collection makes interfacessimpler because they don't need to specify how memory is managed across them.

The current implementation is a parallel mark-and-sweepcollector but a future version might take a different approach.

On the topic of performance, keep in mind that Go gives the programmerconsiderable control over memory layout and allocation, much more thanis typical in garbage-collected languages. A careful programmer can reducethe garbage collection overhead dramatically by using the language well;see the article about[profilingGo programs](http://blog.golang.org/2011/06/profiling-go-programs.html) for a worked example, including a demonstration of Go'sprofiling tools.

Build version go1.4.2.
Except as [noted](https://developers.google.com/site-policies#restrictions),
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a [BSD license](http://golang.org/LICENSE).
[Terms of Service](http://golang.org/doc/tos.html) | 
[Privacy Policy](http://www.google.com/intl/en/policies/privacy/)

来源： <<http://golang.org/doc/faq>>

