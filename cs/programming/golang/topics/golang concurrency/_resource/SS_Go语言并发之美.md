

## [Go语言并发之美](http://www.cnblogs.com/yuxingfirst/archive/2012/11/28/2792366.html)

2012-11-28 12:45

语行

4886

1

编辑

收藏

**简介**

 

​        多核处理器越来越普及，那有没有一种简单的办法，能够让我们写的软件释放多核的威力？答案是：Yes。随着Golang, Erlang, Scale等为并发设计的程序语言的兴起，新的并发模式逐渐清晰。正如过程式编程和面向对象一样，一个好的编程模式需要有一个极其简洁的内核，还有在此之 上丰富的外延，可以解决现实世界中各种各样的问题。本文以GO语言为例，解释其中内核、外延。

 

**并发模式之内核**

 

​        这种并发模式的内核只需要协程和通道就够了。其中协程负责执行代码，通道负责在协程之间传递事件。

　　![Go语言并发之美](https://kshttps0.wiz.cn/wiz-resource/89077880-eff4-11e0-a402-00237def97cc/c40b6e7b-0c55-481b-9932-ba80db581082/index_files/5a07cb01-3e5a-4365-afca-1848f0e5911e.jpg)

 

​        协程是轻量级的线程。在过程式编程中，当调用一个过程的时候，需要等待其执行完才返回。而调用一个协程的时候，不需要等待其执行完，会立即返回。协程十分 轻量，Go语言可以在一个进程中执行有数以十万计的协程，依旧保持高性能。而对于普通的平台，一个进程有数千个线程，其CPU会忙于上下文切换，性能急剧 下降。随意创建线程可不是一个好主意，但是我们可以大量使用的协程。

​        通道是协程之间的数据传输通道。通道可以在众多的协程之间传递数据，具体可以值也可以是个引用。通道有两种使用方式。

​        ·  协程可以试图向通道放入数据，如果通道满了，会挂起协程，直到通道可以为他放入数据为止。

​        ·  协程可以试图向通道索取数据，如果通道没有数据，会挂起协程，直到通道返回数据为止。

​        如此，通道就可以在传递数据的同时，控制协程的运行。有点像事件驱动，也有点像阻塞队列。这两个概念非常的简单，各个语言平台都会有相应的实现。在Java和C上也各有库可以实现两者。

　　![Go语言并发之美]()

　　只要有协程和通道，就可以优雅的解决并发的问题。不必使用其他和并发有关的概念。那如何用这两把利刃解决各式各样的实际问题呢？

 

**并发模式之外延**

 

​        协程相较于线程，可以大量创建。打开这扇门，我们拓展出新的用法，可以做生成器，可以让函数返回“服务”，可以让循环并发执行，还能共享变量。但是出现新 的用法的同时，也带来了新的棘手问题，协程也会泄漏，不恰当的使用会影响性能。下面会逐一介绍各种用法和问题。演示的代码用GO语言写成，因为其简洁明 了，而且支持全部功能。

 

**生成器**

 

​       有的时候，我们需要有一个函数能不断生成数据。比方说这个函数可以读文件，读网络，生成自增长序列，生成随机数。这些行为的特点就是，函数的已知一些变量，如文件路径。然后不断调用，返回新的数据。

![Go语言并发之美]()

下面生成随机数为例，以让我们做一个会并发执行的随机数生成器。

// 函数rand_generator_1 ，返回 int

funcrand_generator_1() int {

​         return rand.Int()

 

​        上面是一个函数，返回一个int。假如rand.Int()这个函数调用需要很长时间等待，那该函数的调用者也会因此而挂起。所以我们可以创建一个协程，专门执行rand.Int()。

 

// 函数rand_generator_2，返回通道(Channel)

funcrand_generator_2() chan int {

​         // 创建通道

​         out := make(chan int)

​         // 创建协程

​         go func() {

​                   for {

​                            //向通道内写入数据，如果无人读取会等待

​                            out <- rand.Int()

​                   }

​         }()

​         return out

} 

funcmain() {

​         // 生成随机数作为一个服务

​         rand_service_handler :=rand_generator_2()

​         // 从服务中读取随机数并打印

​         fmt.Printf("%d\n",<-rand_service_handler)

}

​        上面的这段函数就可以并发执行了rand.Int()。有一点值得注意到函数的返回可以理解为一个“服务”。但我们需要获取随机数据时候，可以随时向这个 服务取用，他已经为我们准备好了相应的数据，无需等待，随要随到。如果我们调用这个服务不是很频繁，一个协程足够满足我们的需求了。但如果我们需要大量访 问，怎么办？我们可以用下面介绍的多路复用技术，启动若干生成器，再将其整合成一个大的服务。

**多路复用**

​        多路复用是让一次处理多个队列的技术。Apache使用处理每个连接都需要一个进程，所以其并发性能不是很好。而Nginx使用多路复用的技术，让一 个进程处理多个连接，所以并发性能比较好。同样，在协程的场合，多路复用也是需要的，但又有所不同。多路复用可以将若干个相似的小服务整合成一个大服务。

![Go语言并发之美]()

那么让我们用多路复用技术做一个更高并发的随机数生成器吧。

// 函数rand_generator_3 ，返回通道(Channel)

funcrand_generator_3() chan int {

​         // 创建两个随机数生成器服务

​         rand_generator_1 := rand_generator_2()

​         rand_generator_2 := rand_generator_2()

 

​         //创建通道

​         out := make(chan int)

 

​         //创建协程

​         go func() {

​                   for {

​                            //读取生成器1中的数据，整合

​                            out <-<-rand_generator_1

​                   }

​         }()

​         go func() {

​                   for {

​                            //读取生成器2中的数据，整合

​                            out <-<-rand_generator_2

​                   }

​         }()

​         return out

}

​        上面是使用了多路复用技术的高并发版的随机数生成器。通过整合两个随机数生成器，这个版本的能力是刚才的两倍。虽然协程可以大量创建，但是众多协程还是会 争抢输出的通道。Go语言提供了Select关键字来解决，各家也有各家窍门。加大输出通道的缓冲大小是个通用的解决方法。

​        多路复用技术可以用来整合多个通道。提升性能和操作的便捷。配合其他的模式使用有很大的威力。

**Future技术**

​        Future是一个很有用的技术，我们常常使用Future来操作线程。我们可以在使用线程的时候，可以创建一个线程，返回Future，之后可以通过它等待结果。  但是在协程环境下的Future可以更加彻底，输入参数同样可以是Future的。

![Go语言并发之美]()

调用一个函数的时候，往往是参数已经准备好了。调用协程的时候也同样如此。但是如果我们将传入的参 数设为通道，这样我们就可以在不准备好参数的情况下调用函数。这样的设计可以提供很大的自由度和并发度。函数调用和函数参数准备这两个过程可以完全解耦。 下面举一个用该技术访问数据库的例子。

//一个查询结构体

typequery struct {

​         //参数Channel

​         sql chan string

​         //结果Channel

​         result chan string

}

//执行Query

funcexecQuery(q query) {

​         //启动协程

​         go func() {

​                   //获取输入

​                   sql := <-q.sql

​                   //访问数据库，输出结果通道

​                   q.result <- "get" + sql

​         }()

}

funcmain() {

​         //初始化Query

​         q :=

​                   query{make(chan string, 1),make(chan string, 1)}

​         //执行Query，注意执行的时候无需准备参数

​         execQuery(q)

 

​         //准备参数

​         q.sql <- "select * fromtable"

​         //获取结果

​         fmt.Println(<-q.result)

}

​        上面利用Future技术，不单让结果在Future获得，参数也是在Future获取。准备好参数后，自动执行。Future和生成器的区别在 于，Future返回一个结果，而生成器可以重复调用。还有一个值得注意的地方，就是将参数Channel和结果Channel定义在一个结构体里面作为 参数，而不是返回结果Channel。这样做可以增加聚合度，好处就是可以和多路复用技术结合起来使用。

​        Future技术可以和各个其他技术组合起来用。可以通过多路复用技术，监听多个结果Channel，当有结果后，自动返回。也可以和生成器组合使用，生 成器不断生产数据，Future技术逐个处理数据。Future技术自身还可以首尾相连，形成一个并发的pipe filter。这个pipe filter可以用于读写数据流，操作数据流。

​        Future是一个非常强大的技术手段。可以在调用的时候不关心数据是否准备好，返回值是否计算好的问题。让程序中的组件在准备好数据的时候自动跑起来。

**并发循环**

​       循环往往是性能上的热点。如果性能瓶颈出现在CPU上的话，那么九成可能性热点是在一个循环体内部。所以如果能让循环体并发执行，那么性能就会提高很多。

![Go语言并发之美]()

要并发循环很简单，只有在每个循环体内部启动协程。协程作为循环体可以并发执行。调用启动前设置一个计数器，每一个循环体执行完毕就在计数器上加一个元素，调用完成后通过监听计数器等待循环协程全部完成。

//建立计数器

sem :=make(chan int, N);

//FOR循环体

for i,xi:= range data {

​         //建立协程

​    go func (i int, xi float) {

​        doSomething(i,xi);

​                   //计数

​        sem <- 0;

​    } (i, xi);

}

// 等待循环结束

for i := 0; i < N; ++i { <-sem }

​       上面是一个并发循环例子。通过计数器来等待循环全部完成。如果结合上面提到的Future技术的话，则不必等待。可以等到真正需要的结果的地方，再去检查数据是否完成。

​        通过并发循环可以提供性能，利用多核，解决CPU热点。正因为协程可以大量创建，才能在循环体中如此使用，如果是使用线程的话，就需要引入线程池之类的东西，防止创建过多线程，而协程则简单的多。

**ChainFilter技术**

​      前面提到了Future技术首尾相连，可以形成一个并发的pipe filter。这种方式可以做很多事情，如果每个Filter都由同一个函数组成，还可以有一种简单的办法把他们连起来。

![Go语言并发之美]()

由于每个Filter协程都可以并发运行，这样的结构非常有利于多核环境。下面是一个例子，用这种模式来产生素数。

// Aconcurrent prime sieve

packagemain

 

// Sendthe sequence 2, 3, 4, ... to channel 'ch'.

funcGenerate(ch chan<- int) {

​         for i := 2; ; i++ {

​                  ch<- i // Send 'i' to channel 'ch'.

​         }

}

// Copythe values from channel 'in' to channel 'out',

//removing those divisible by 'prime'.

funcFilter(in <-chan int, out chan<- int, prime int) {

​         for {

​                   i := <-in // Receive valuefrom 'in'.

​                   if i%prime != 0 {

​                            out <- i // Send'i' to 'out'.

​                   }

​         }

}

// Theprime sieve: Daisy-chain Filter processes.

funcmain() {

​         ch := make(chan int) // Create a newchannel.

​         go Generate(ch)      // Launch Generate goroutine.

​         for i := 0; i < 10; i++ {

​                   prime := <-ch

​                   print(prime, "\n")

​                   ch1 := make(chan int)

​                   go Filter(ch, ch1, prime)

​                   ch = ch1

​         }

}

​        上面的程序创建了10个Filter，每个分别过滤一个素数，所以可以输出前10个素数。   

​        Chain-Filter通过简单的代码创建并发的过滤器链。这种办法还有一个好处，就是每个通道只有两个协程会访问，就不会有激烈的竞争，性能会比较好。

**共享变量**

**       ** 协程之间的通信只能够通过通道。但是我们习惯于共享变量，而且很多时候使用共享变量能让代码更简洁。比如一个Server有两个状态开和关。其他仅仅希望获取或改变其状态，那又该如何做呢。可以将这个变量至于0通道中，并使用一个协程来维护。

![Go语言并发之美]()

下面的例子描述如何用这个方式，实现一个共享变量。

//共享变量有一个读通道和一个写通道组成

typesharded_var struct {

​         reader chan int

​         writer chan int

}

//共享变量维护协程

funcsharded_var_whachdog(v sharded_var) {

​         go func() {

​                   //初始值

​                   var value int = 0

​                   for {

​                            //监听读写通道，完成服务

​                            select {

​                            case value =<-v.writer:

​                            case v.reader <-value:

​                            }

​                   }

​         }()

}

funcmain() {

​         //初始化，并开始维护协程

​         v := sharded_var{make(chan int),make(chan int)}

​         sharded_var_whachdog(v)

​         //读取初始值

​         fmt.Println(<-v.reader)

​         //写入一个值

​         v.writer <- 1

​         //读取新写入的值

​         fmt.Println(<-v.reader)

}

​        这样，就可以在协程和通道的基础上实现一个协程安全的共享变量了。定义一个写通道，需要更新变量的时候，往里写新的值。再定义一个读通道，需要读的时候，从里面读。通过一个单独的协程来维护这两个通道。保证数据的一致性。

​        一般来说，协程之间不推荐使用共享变量来交互，但是按照这个办法，在一些场合，使用共享变量也是可取的。很多平台上有较为原生的共享变量支持，到底用那种 实现比较好，就见仁见智了。另外利用协程和通道，可以还实现各种常见的并发数据结构，如锁等等，就不一一赘述。

 

**协程泄漏**

​        协程和内存一样，是系统的资源。对于内存，有自动垃圾回收。但是对于协程，没有相应的回收机制。会不会若干年后，协程普及了，协程泄漏和内存泄漏一样成为 程序员永远的痛呢？一般而言，协程执行结束后就会销毁。协程也会占用内存，如果发生协程泄漏，影响和内存泄漏一样严重。轻则拖慢程序，重则压垮机器。

​        C和C++都是没有自动内存回收的程序设计语言，但只要有良好的编程习惯，就能解决规避问题。对于协程是一样的，只要有好习惯就可以了。

​        只有两种情况会导致协程无法结束。一种情况是协程想从一个通道读数据，但无人往这个通道写入数据，或许这个通道已经被遗忘了。还有一种情况是程想往一个通道写数据，可是由于无人监听这个通道，该协程将永远无法向下执行。下面分别讨论如何避免这两种情况。

![Go语言并发之美]()

funcnever_leak(ch chan int) {

​         //初始化timeout，缓冲为1

​         timeout := make(chan bool, 1)

​         //启动timeout协程，由于缓存为1，不可能泄露

​         go func() {

​                   time.Sleep(1 * time.Second)

​                   timeout <- true

​         }()

​         //监听通道，由于设有超时，不可能泄露

​         select {

​         case <-ch:

​                   // a read from ch hasoccurred

​         case <-timeout:

​                   // the read from ch has timedout

​         }

}

​        上面是个避免泄漏例子。使用超时避免读堵塞，使用缓冲避免写堵塞。

 

**并发模式之实现**

​        在并发编程大行其道的今天，对协程和通道的支持成为各个平台比不可少的一部分。虽然各家有各家的叫法，但都能满足协程的基本要求—并发执行和可大量创建。笔者对他们的实现方式总结了一下。

![Go语言并发之美]()

​        令人惊奇的是C/C++和Java这三个世界上最主流的平台没有在对协程提供语言级别的原生支持。他们都背负着厚重的历史，无法改变，也无需改变。但他们还有其他的办法使用协程。

​        Java平台有很多方法实现协程：

​        · 修改虚拟机：对JVM打补丁来实现协程，这样的实现效果好，但是失去了跨平台的好处

​        · 修改字节码：在编译完成后增强字节码，或者使用新的JVM语言。稍稍增加了编译的难度。

​        · 使用JNI：在Jar包中使用JNI，这样易于使用，但是不能跨平台。

​        · 使用线程模拟协程：使协程重量级，完全依赖JVM的线程实现。

​        其中修改字节码的方式比较常见。因为这样的实现办法，可以平衡性能和移植性。最具代表性的JVM语言Scale就能很好的支持协程并发。流行的Java Actor模型类库akka也是用修改字节码的方式实现的协程。

​        对于C语言，协程和线程一样。可以使用各种各样的系统调用来实现。协程作为一个比较高级的概念，实现方式实在太多，就不讨论了。比较主流的实现有libpcl, coro,lthread等等。

​        对于C++，有Boost实现，还有一些其他开源库。还有一门名为μC++语言，在C++基础上提供了并发扩展。

 

**结语 **

 

​        本文探讨了一个极其简洁的并发模型。在只有协程和通道这两个基本元件的情况下。可以提供丰富的功能，解决形形色色实际问题。而且这个模型已经被广泛的实 现，成为潮流。相信这种并发模型的功能远远不及此，一定也会有更多更简洁的用法出现。或许未来CPU核心数目将和人脑神经元数目一样多，到那个时候，我们 又要重新思考并发模型了。

 

转载自： 　　http://qing.weibo.com/2294942122/88ca09aa33002ele.html

分类: [后端架构](http://www.cnblogs.com/yuxingfirst/category/433119.html)

来源： <<http://www.cnblogs.com/yuxingfirst/archive/2012/11/28/2792366.html>>

 

------

## [[阅读笔记\]Go语言并发之美](http://www.cnblogs.com/yjf512/archive/2012/11/30/2796892.html)

2012-11-30 23:10 by 轩脉刃, 1835 阅读, 0 评论, [收藏](http://www.cnblogs.com/yjf512/archive/2012/11/30/2796892.html#), [编辑](http://i.cnblogs.com/EditPosts.aspx?postid=2796892)

文章题目：
​     Go语言并发之美
文章链接：
   http://qing.weibo.com/2294942122/88ca09aa33002ele.html
分享笔记：
​     这篇文章说的是go routine和channel在Go语言中的应用。刚开始看的时候，对文章使用lua的协程来描述goroutine还真是不习惯。建议读者不要跟者作者使用这样的称呼。
并发在Go中得到语言级别的支持。文章列出了几个goroutine和channel的使用方法
1 id生成器
由于id生成器会产生系统调用，所以假设生成随机数这个id生成函数需要很长时间。这个时候就可以使用到并发了。当一个goroutine在运行的时候，另外一个id生成的goroutine在生成id。
2 多路复用
多路复用就是一个动作可以管理或者监听多个并发线程（这里是goroutine）。文中的例子就是使用一个chan来监听多个goroutine，一旦有一个goroutine对chan进行操作，下面的程序就进行了。
例子的最后也说了，实际上Go也提供了select关键字，因此多路复用也可以使用select来对多个chan进行监听，每个goroutine来通过一个chan来传递消息。
3 实现并发中的future技术
future技术是一种并发模式，需要并发处理的时候，创建goroutine返回一个future，当需要这个future返回东西的时候，去future中获取数据。这样的好处就是在编程的时候的思维逻辑是流式的了。
4 并发循环
使用goroutine来提高循环的效率是最容易想到的优化效率的方法了。
5 chainFilter技术
并发的过滤器可以使用goroutine来使用。这个记得nginx的output就是使用chainFilter这样的模式来实现。
6 共享变量
并发过程中的共享变量的使用有可能发生冲突。当然首选会想到使用锁来对共享变量进行控制。
在golang中也可以使用channel来维护共享变量，实际达到的也是锁的功效。
文中的例子使用一个写通道和一个读通道来保持一个共享变量，只能从写通道写入，这个时候，其他的goroutine要使用写通道是不行的，这就达到了写锁的功能。读的功能也是一样的。
7 使用超时来控制协程泄露
协程泄露说的是协程没有合理控制结束（回收）导致协程无法结束，最终导致程序阻塞无法执行了。
这种情况可以使用超时，使用超时就是另外开启一个goroutine来计时，主goroutine使用多路复用监听要监听的goroutine和计时goroutine。记得某个讲goroutine并发的视频也说到这个。在实际项目中，记得给每个可能“泄露”的goroutine加上计时器是尤为重要的。
ps： 最后吐槽下，这篇文章的程序排版真是不爽。

来源： <<http://www.cnblogs.com/yjf512/archive/2012/11/30/2796892.html>>

