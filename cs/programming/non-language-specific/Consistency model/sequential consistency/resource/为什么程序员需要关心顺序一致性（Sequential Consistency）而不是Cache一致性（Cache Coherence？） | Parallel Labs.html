<!DOCTYPE html>
<html lang="zh-CN" class="no-js">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="profile" href="http://gmpg.org/xfn/11">
		<link rel="pingback" href="http://www.parallellabs.com/xmlrpc.php">
		<script>(function(html){html.className = html.className.replace(/\bno-js\b/,'js')})(document.documentElement);</script>
<title>为什么程序员需要关心顺序一致性（Sequential Consistency）而不是Cache一致性（Cache Coherence？） | Parallel Labs</title>

<!-- All in One SEO Pack 2.3.14 by Michael Torbert of Semper Fi Web Design[395,493] -->
<meta name="description"  content="本文适合的对象是想用C++或者Java进行多线程编程的程序员。本文主要包括对Sequential Consistency和Cache Coherence的概念性介绍并给出了一些相关例子，目的是帮助程序员明白为什么需要在并行编程时关注Sequential Consistency。" />

<meta name="keywords"  content="多线程,多核,sequential consistency,顺序一致性,缓存一致性,cache coherency,memory model,内存模型,并行编程" />

<link rel="canonical" href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/" />
<!-- /all in one seo pack -->
<link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="Parallel Labs  &raquo; Feed" href="http://www.parallellabs.com/feed/" />
<link rel="alternate" type="application/rss+xml" title="Parallel Labs  &raquo; 评论Feed" href="http://www.parallellabs.com/comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="Parallel Labs  &raquo; 为什么程序员需要关心顺序一致性（Sequential Consistency）而不是Cache一致性（Cache Coherence？）评论Feed" href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/feed/" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/svg\/","svgExt":".svg","source":{"concatemoji":"http:\/\/www.parallellabs.com\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.8"}};
			!function(a,b,c){function d(a){var b,c,d,e,f=String.fromCharCode;if(!k||!k.fillText)return!1;switch(k.clearRect(0,0,j.width,j.height),k.textBaseline="top",k.font="600 32px Arial",a){case"flag":return k.fillText(f(55356,56826,55356,56819),0,0),b=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,56826,8203,55356,56819),0,0),c=j.toDataURL(),b===c&&(k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447),0,0),b=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447),0,0),c=j.toDataURL(),b!==c);case"emoji4":return k.fillText(f(55358,56794,8205,9794,65039),0,0),d=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55358,56794,8203,9794,65039),0,0),e=j.toDataURL(),d!==e}return!1}function e(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g,h,i,j=b.createElement("canvas"),k=j.getContext&&j.getContext("2d");for(i=Array("flag","emoji4"),c.supports={everything:!0,everythingExceptFlag:!0},h=0;h<i.length;h++)c.supports[i[h]]=d(i[h]),c.supports.everything=c.supports.everything&&c.supports[i[h]],"flag"!==i[h]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[i[h]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='stylesheet' id='genericons-css'  href='http://parallellabs.qiniudn.com/wp-content/themes/twentysixteen/genericons/genericons.css?ver=3.4.1' type='text/css' media='all' />
<link rel='stylesheet' id='twentysixteen-style-css'  href='http://parallellabs.qiniudn.com/wp-content/themes/twentysixteen/style.css?ver=4.8' type='text/css' media='all' />
<!--[if lt IE 10]>
<link rel='stylesheet' id='twentysixteen-ie-css'  href='http://parallellabs.qiniudn.com/wp-content/themes/twentysixteen/css/ie.css?ver=20160816' type='text/css' media='all' />
<![endif]-->
<!--[if lt IE 9]>
<link rel='stylesheet' id='twentysixteen-ie8-css'  href='http://parallellabs.qiniudn.com/wp-content/themes/twentysixteen/css/ie8.css?ver=20160816' type='text/css' media='all' />
<![endif]-->
<!--[if lt IE 8]>
<link rel='stylesheet' id='twentysixteen-ie7-css'  href='http://parallellabs.qiniudn.com/wp-content/themes/twentysixteen/css/ie7.css?ver=20160816' type='text/css' media='all' />
<![endif]-->
<!--[if lt IE 9]>
<script type='text/javascript' src='http://parallellabs.qiniudn.com/wp-content/themes/twentysixteen/js/html5.js?ver=3.7.3'></script>
<![endif]-->
<script type='text/javascript' src='http://parallellabs.qiniudn.com/wp-includes/js/jquery/jquery.js?ver=1.12.4'></script>
<script type='text/javascript' src='http://parallellabs.qiniudn.com/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='http://www.parallellabs.com/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.parallellabs.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://parallellabs.qiniudn.com/wp-includes/wlwmanifest.xml" /> 
<link rel='prev' title='八条设计多线程程序的简单规则' href='http://www.parallellabs.com/2010/02/18/8-simple-rules-for-designing-multithreaded-applications/' />
<link rel='next' title='实施并行编程的五大障碍' href='http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/' />
<meta name="generator" content="WordPress 4.8" />
<link rel='shortlink' href='http://www.parallellabs.com/?p=367' />
<link rel="alternate" type="application/json+oembed" href="http://www.parallellabs.com/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fwww.parallellabs.com%2F2010%2F03%2F06%2Fwhy-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence%2F" />
<link rel="alternate" type="text/xml+oembed" href="http://www.parallellabs.com/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fwww.parallellabs.com%2F2010%2F03%2F06%2Fwhy-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence%2F&#038;format=xml" />
<link rel="stylesheet" href="http://parallellabs.qiniudn.com/wp-content/plugins/wp-page-numbers/classic/wp-page-numbers.css" type="text/css" media="screen" />		<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
</head>

<body class="post-template-default single single-post postid-367 single-format-standard">
<div id="page" class="site">
	<div class="site-inner">
		<a class="skip-link screen-reader-text" href="#content">跳至内容</a>

		<header id="masthead" class="site-header" role="banner">
			<div class="site-header-main">
				<div class="site-branding">
					
											<p class="site-title"><a href="http://www.parallellabs.com/" rel="home">Parallel Labs </a></p>
											<p class="site-description">Be a lifelong learner with a natural curiosity to figure out how the world works, and passion to shape the world to come by crafting the next big thing. Don&#039;t worry dude, just hacking!</p>
									</div><!-- .site-branding -->

							</div><!-- .site-header-main -->

					</header><!-- .site-header -->

		<div id="content" class="site-content">

<div id="primary" class="content-area">
	<main id="main" class="site-main" role="main">
		
<article id="post-367" class="post-367 post type-post status-publish format-standard hentry category-parallel-programming tag-multicore tag-memory-model tag-multithreaded-programming">
	<header class="entry-header">
		<h1 class="entry-title">为什么程序员需要关心顺序一致性（Sequential Consistency）而不是Cache一致性（Cache Coherence？）</h1>	</header><!-- .entry-header -->

				<div class="entry-summary">
				<p>本文所讨论的计算机模型是Shared Memory Multiprocessor，即我们现在常见的共享内存的多核CPU。本文适合的对象是想用C++或者Java进行多线程编程的程序员。本文主要包括对Sequential Consistency和Cache Coherence的概念性介绍并给出了一些相关例子，目的是帮助程序员明白为什么需要在并行编程时关注Sequential Consistency。</p>
<p><a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/">阅读全文>></a> </p>
			</div><!-- .entry-summary -->
		
	
	<div class="entry-content">
		<p><em><span style="color: #0000ff;">最后一次修改：2010年11月11日</span></em></p>
<p>本文所讨论的计算机模型是Shared Memory Multiprocessor，即我们现在常见的共享内存的多核CPU。本文适合的对象是想用C++或者Java进行多线程编程的程序员。本文主要包括对Sequential Consistency和Cache Coherence的概念性介绍并给出了一些相关例子，目的是帮助程序员明白为什么需要在并行编程时关注Sequential Consistency。</p>
<p>Sequential Consistency（下文简称SC）是Java内存模型和即将到来的C++0x内存模型的一个关键概念，它是一个最直观最易理解的多线程程序执行顺序的模型。Cache Coherence（下文简称CC）是多核CPU在硬件中已经实现的一种机制，简单的说，它确保了对在多核CPU的Cache中一个地址的读操作一定会返回那个地址最新的（被写入）的值。</p>
<p>那么为什么程序员需要关心SC呢？因为现在的硬件和编译器出于性能的考虑会对程序作出违反SC的优化，而这种优化会影响多线程程序的正确性，也就是说你用C++编写的多线程程序可能会得到的不是你想要的错误的运行结果。Java从JDK1.5开始加入SC支持，所以Java程序员在进行多线程编程时需要注意使用Java提供的相关机制来确保你程序的SC。程序员之所以不需要关心CC的细节是因为现在它已经被硬件给自动帮你保证了（不是说程序员完全不需要关心CC，实际上对程序员来说理解CC的大致工作原理也是很有帮助的，典型的如避免多线程程序的<a href="http://blog.yufeng.info/archives/783">伪共享问题</a>，即<a href="http://en.wikipedia.org/wiki/False_sharing">False Sharing</a>）。</p>
<p>那么什么是SC，什么是CC呢？</p>
<h3>1. Sequential Consistency (顺序一致性）</h3>
<p>SC的作者Lamport给的严格定义是：<br />
<em>&#8220;&#8230; the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.&#8221;</em></p>
<p>这个概念初次理解起来拗口，不过不要紧，下面我会给出个很直观的例子帮助理解。</p>
<p>假设我们有两个线程（线程1和线程2）分别运行在两个CPU上，有两个初始值为0的全局共享变量x和y，两个线程分别执行下面两条指令：</p>
<p>初始条件： x = y = 0;</p>
<table style="font-size: 1em; line-height: inherit; border-collapse: collapse;" border="1" cellspacing="0" cellpadding="3" width="100%" bordercolor="#000000">
<tbody>
<tr style="text-align: left;">
<td style="text-align: center;" width="50%"><em>线程 1</em></td>
<td style="text-align: center;" width="50%"><em>线程 2</em></td>
</tr>
<tr style="text-align: left;">
<td style="text-align: center;" width="50%">x = 1;</td>
<td style="text-align: center;" width="50%">y=1;</td>
</tr>
<tr style="text-align: left;">
<td style="text-align: center;" width="50%">r1 = y;</td>
<td style="text-align: center;" width="50%">r2 = x;</td>
</tr>
</tbody>
</table>
<p>因为多线程程序是交错执行的，所以程序可能有如下几种执行顺序：</p>
<table style="font-size: 1em; line-height: inherit; border-collapse: collapse;" border="1" cellspacing="0" cellpadding="3" width="100%" bordercolor="#000000">
<tbody></tbody>
</table>
<table style="font-size: 1em; line-height: inherit; border-collapse: collapse;" border="1" cellspacing="0" cellpadding="3" width="100%" bordercolor="#000000">
<tbody>
<tr style="text-align: left;">
<td style="text-align: center;" width="33.333333333333336%">Execution 1</td>
<td style="text-align: center;" width="33.333333333333336%">Execution 2</td>
<td style="text-align: center;" width="33.333333333333336%">Execution 3</td>
</tr>
<tr style="text-align: left;">
<td width="33.333333333333336%">
<div style="margin-top: 0px; margin-bottom: 0px;">x = 1;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">r1 = y;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">y = 1;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">r2 = x;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">结果:r1==0 and r2 == 1</div>
</td>
<td width="33.333333333333336%">
<div style="margin-top: 0px; margin-bottom: 0px;">y = 1;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">r2 = x;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">x = 1;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">r1 = y;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">结果: r1 == 1 and r2 == 0</div>
</td>
<td width="33.333333333333336%">
<div style="margin-top: 0px; margin-bottom: 0px;">x = 1;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">y = 1;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">r1 = y;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">r2 = x;</div>
<div style="margin-top: 0px; margin-bottom: 0px;">结果: r1 == 1 and r2 == 1</div>
</td>
</tr>
</tbody>
</table>
<p>当然上面三种情况并没包括所有可能的执行顺序，但是它们已经包括所有可能出现的结果了，所以我们只举上面三个例子。我们注意到这个程序只可能出现上面三种结果，但是不可能出现r1==0 and r2==0的情况。</p>
<p>SC其实就是规定了两件事情：<br />
（1）每个线程内部的指令都是按照程序规定的顺序（program order）执行的（单个线程的视角）<br />
（2）线程执行的交错顺序可以是任意的，但是所有线程所看见的整个程序的总体执行顺序都是一样的（整个程序的视角）</p>
<p>第一点很容易理解，就是说线程1里面的两条语句一定在该线程中一定是x=1先执行，r1=y后执行。第二点就是说线程1和线程2所看见的整个程序的执行顺序都是一样的，举例子就是假设线程1看见整个程序的执行顺序是我们上面例子中的Execution 1，那么线程2看见的整个程序的执行顺序也是Execution 1，不能是Execution 2或者Execution 3。</p>
<p>有一个更形象点的例子。伸出你的双手，掌心面向你，两个手分别代表两个线程，从食指到小拇指的四根手指头分别代表每个线程要依次执行的四条指令。SC的意思就是说：<br />
（1）对每个手来说，它的四条指令的执行顺序必须是从食指执行到小拇指<br />
（2）你两个手的八条指令（八根手指头）可以在满足（1）的条件下任意交错执行（例如可以是左1，左2，右1，右2，右3，左3，左4，右4，也可以是左1，左2，左3，左4，右1，右2，右3，右4，也可以是右1，右2，右3，左1，左2，右4，左3，左4等等等等）</p>
<p>其实说简单点，SC就是我们最容易理解的那个多线程程序执行顺序的模型。</p>
<h3>2. Cache Conherence （缓存一致性）</h3>
<p>那么CC是干什么用的呢？这个要详细说的话就复杂了，写一本书绰绰有余。简单来说，我们知道现在的多核CPU的Cache是多层结构，一般每个CPU核心都会有一个私有的L1级和L2级Cache，然后多个CPU核心共享一个L3级缓存，这样的设计是出于提高内存访问性能的考虑。但是这样就有一个问题了，每个CPU核心之间的私有L1，L2级缓存之间需要同步啊。比如说，CPU核心1上的线程A对一个共享变量global_counter进行了加1操作，这个被写入的新值存到CPU核心1的L1缓存里了；此时另一个CPU核心2上的线程B要读global_counter了，但是CPU核心2的L1缓存里的global_counter的值还是旧值，最新被写入的值现在还在CPU核心1上呢！怎么把？这个任务就交给CC来完成了！</p>
<p>CC是Cache之间的一种同步协议，它其实保证的就是对某一个地址的读操作返回的值一定是那个地址的最新值，而这个最新值可能是该线程所处的CPU核心刚刚写进去的那个最新值，也可能是另一个CPU核心上的线程刚刚写进去的最新值。举例来说，上例的Execution 3中，r1 = y是对y进行读操作，该读操作一定会返回在它之前已经执行的那条指令y=1对y写入的最新值。可能程序员会说这个不是显而意见的么？r1肯定是1啊，因为y=1已经执行了。其实这个看似简单的”显而易见“在多核processor的硬件实现上是有很多文章的，因为y=1是在另一个CPU上发生的事情，你怎么确保你这个读操作能立刻读到别的CPU核心刚刚写入的值？不过对程序员来讲你不需要关心CC，因为CPU已经帮你搞定这些事情了，不用担心多核CPU上不同Cache之间的同步的问题了（感兴趣的朋友可以看看体系结构的相关书籍，现在的多核CPU一般是以MESI protocol为原型来实现CC）。<strong>总结一下，CC和SC其实是相辅相承的，前者保证对单个地址的读写正确性，后者保证整个程序对多个地址读写的正确性，两者共同保证多线程程序执行的正确性。</strong></p>
<h3>3. 为什么要关心SC？</h3>
<p>好，回到SC的话题。为什么说程序员需要关心SC？因为现在的CPU和编译器会对代码做各种各样的优化，有时候它们可能会为了优化性能而把程序员在写程序时规定的代码执行顺序(program order)打乱，导致程序执行结果是错误的。</p>
<p>例如编译器可能会做如下优化，即把线程1的两条语序调换执行顺序：<br />
初始条件： x=y=0;</p>
<table style="font-size: 1em; line-height: inherit; border-collapse: collapse;" border="1" cellspacing="0" cellpadding="3" width="100%" bordercolor="#000000">
<tbody>
<tr style="text-align: left;">
<td style="text-align: center;" width="50%"><em><span style="font-size: x-small;">线程 1</span></em></td>
<td style="text-align: center;" width="50%"><em><span style="font-size: x-small;">线程 2</span></em></td>
</tr>
<tr style="text-align: left;">
<td style="text-align: center;" width="50%"><span style="font-size: x-small;">r1 = y;</span></td>
<td style="text-align: center;" width="50%"><span style="font-size: x-small;">y=1;</span></td>
</tr>
<tr style="text-align: left;">
<td style="text-align: center;" width="50%"><span style="font-size: x-small;">x = 1;</span></td>
<td style="text-align: center;" width="50%"><span style="font-size: x-small;">r2 = x;</span></td>
</tr>
</tbody>
</table>
<p>那么这个时候程序如果按如下顺序执行就可能就会出现r1==r2==0这样程序员认为”不正确“的结果：</p>
<table style="font-size: 1em; line-height: inherit; border-collapse: collapse;" border="1" cellspacing="0" cellpadding="3" width="100%" bordercolor="#000000">
<tbody>
<tr style="text-align: left;">
<td style="text-align: center;" width="100%">Execution 4</td>
</tr>
<tr style="text-align: left;">
<td style="text-align: center;" width="100%">r1 = y;<br />
y = 1;<br />
r2 = x;<br />
x = 1;</td>
</tr>
</tbody>
</table>
<p>为什么编译器会做这样的优化呢？因为读一个在内存中而不是在cache中的共享变量需要很多周期，所以编译器就”自作聪明“的让读操作先执行，从而隐藏掉一些指令执行的latency，提高程序的性能。实际上这种类似的技术是在单核时代非常普遍的优化方法，但是在进入多核时代后编译器没跟上发展，导致了对多线程程序进行了违反SC的错误优化。为什么编译器很难保证SC？因为对编译器来讲它很难知道多个线程在执行时会按照什么样的交错顺序执行，因为这需要一个整个程序运行时的视角，而只对一份静态的代码做优化的编译器是很难得到这种运行时的上下文的。那么为什么硬件也保证不了呢？因为CPU硬件中的写缓冲区（store buffer）会把要写入memory的值缓存起来，然后当前线程继续往下执行，而这个被缓存的值可能要很晚才会被其他线程“看见”，从而导致多线程程序逻辑出错。其实硬件也提供了一些例如Memory Barrier等解决方案，但是开销是一个比较大的问题，而且很多需要程序员手动添加memory barrier，现在还不能指望CPU或者编译器<strong>自动</strong>帮你搞定这个问题。（感兴趣的朋友可以在本文的参考文献中发现很多硬件优化造成SC被违反的例子以及Memory Barrier等解决方案）</p>
<p>好了，我们发现为了保证多线程的正确性，我们希望程序能按照SC模型执行；但是SC的对性能的损失太大了，CPU硬件和编译器为了提高性能就必须要做优化啊！为了既保证正确性又保证性能，在经过十几年的研究后一个新的新的模型出炉了：sequential consistency for data race free programs。简单地说这个模型的原理就是对没有data race的程序可以保证它是遵循SC的，这个模型在多线程程序的正确性和性能间找到了一个平衡点。对广大程序员来说，我们依赖高级语言内建的内存模型来帮我们保证多线程程序的正确性。例如，从JDK1.5开始引入的Java内存模型中已经支持data race free的SC了（例如使用volatile关键字，atomic变量等），但是C++程序员就需要等待C++0x中新的内存模型的atomic类型等来帮助保证SC了(因为atomic类型的值具有acquire和release语义，它隐式地调用了memory barrier指令)。什么意思呢？说简单点，就是由程序员用同步原语（例如锁或者atomic的同步变量）来保证你程序是没有data race的，这样CPU和编译器就会保证你程序是按你所想的那样执行的（即SC），是正确的。换句话说，程序员只需要恰当地使用具有acquire和release语义的同步原语标记那些真正需要同步的变量和操作，就等于告诉CPU和编译器你们不要对这些标记出来的操作和变量做违反SC的优化，而其它未被标记的地方你们可以随便优化，这样既保证了正确性又保证了CPU和编译器可以做尽可能多的性能优化。<del datetime="2010-10-26T10:19:54+00:00">来告诉编译器和CPU这里这里你不能做违反SC的优化，那里那里你不能做违反SC的优化，然后你写的程序就会得到正确的执行结果了。</del></p>
<p>从根源上来讲，在串行时代，编译器和CPU对代码所进行的乱序执行的优化对程序员都是封装好了的，无痛的，所以程序员不需要关心这些代码在执行时被乱序成什么样子，因为这些都被编译器和CPU封装起来了，你不用担心内部细节，它最终表现出来的行为就是按你想要的那种方式执行的。但是进入多核时代，程序员、编译器、CPU三者之间未能达成一致（例如诸如C/C++之类的编程语言没有引入多线程），所以CPU、编译器就会时不时地给你捣蛋，故作聪明的做一些优化，让你的程序不会按照你想要的方式执行，是错误的。Java作为引入多线程的先驱从1.5开始支持内存模型，等于是帮助程序员达成了与编译器、CPU（以及JVM）之间的契约，程序员只要正确的使用同步原语就可以保证程序最终表现出来的行为跟你所想的一样（即我们最容易理解的SC模型），是正确的。</p>
<p>本文并未详细介绍所有针对SC问题的解决方案（例如X86对SC的支持，Java对它的支持，C++对它的支持等等），如果想了解更多，可以参考本文所指出的参考文献。下一次我会写一篇关于data race free model, weak ordering, x86 memory model等相关概念的文章，敬请期待。</p>
<h3>题外话：</h3>
<p>并行编程是非常困难的，在多核时代的程序员不能指望硬件和编译器来帮你搞定所有的事情，努力学习多核多线程编程的一些基础知识是很有必要的，至少你应该知道你的程序到底会以什么样的方式被执行。</p>
<p>参考文献：<br />
<a href="http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/threadsintro.html">[1] Hans Boehm: C++ Memory Model</a><br />
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">[2] Bill Pugh: The Java Memory Model</a><br />
<a href="http://en.wikipedia.org/wiki/Cache_coherence">[3] Wiki: Cache Coherence</a><br />
<a href="http://en.wikipedia.org/wiki/Sequential_consistency">[4] Wiki: Sequential Consistency</a><br />
<a href="http://ivanwangcn.spaces.live.com/blog/cns!F291BBD27380D1CA!153.entry">[5] The Memory Model of X86 (中文，从硬件角度讲SC问题)</a><br />
<a href="http://blog.csdn.net/pongba/archive/2007/06/20/1659952.aspx">[6] 《C++0x漫谈》系列之：多线程内存模型</a></p>
	</div><!-- .entry-content -->

	<footer class="entry-footer">
		<span class="byline"><span class="author vcard"><img alt='' src='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=49&#038;r=g' srcset='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=98&amp;r=g 2x' class='avatar avatar-49 photo' height='49' width='49' /><span class="screen-reader-text">作者 </span> <a class="url fn n" href="http://www.parallellabs.com/author/admin/">Guancheng (G.C.)</a></span></span><span class="posted-on"><span class="screen-reader-text">发布于 </span><a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/" rel="bookmark"><time class="entry-date published" datetime="2010-03-06T14:01:48+00:00">03/06/2010</time><time class="updated" datetime="2013-07-22T18:07:43+00:00">07/22/2013</time></a></span><span class="cat-links"><span class="screen-reader-text">分类 </span><a href="http://www.parallellabs.com/category/parallel-programming/" rel="category tag">并行编程</a></span><span class="tags-links"><span class="screen-reader-text">标签 </span><a href="http://www.parallellabs.com/tag/multicore/" rel="tag">多核</a>、<a href="http://www.parallellabs.com/tag/memory-model/" rel="tag">多线程内存模型</a>、<a href="http://www.parallellabs.com/tag/multithreaded-programming/" rel="tag">多线程编程</a></span>			</footer><!-- .entry-footer -->
</article><!-- #post-## -->

<div id="comments" class="comments-area">

			<h2 class="comments-title">
			《为什么程序员需要关心顺序一致性（Sequential Consistency）而不是Cache一致性（Cache Coherence？）》有43个想法		</h2>

		
		<ol class="comment-list">
					<li id="comment-22" class="comment even thread-even depth-1 parent">
			<article id="div-comment-22" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://1.gravatar.com/avatar/47f6c93c861ef45438c9b7d7f88a0ac2?s=42&#038;r=g' srcset='http://1.gravatar.com/avatar/47f6c93c861ef45438c9b7d7f88a0ac2?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">zade</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-22">
							<time datetime="2010-03-09T03:52:17+00:00">
								03/09/2010 03:52							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>按照我的理解,作者的意思是SC是通过避免乱序优化保证程序的正确性,并且在C++中实现这个的手段是atomic operation.</p>
<p>如果我的理解是正确的,那么我的疑问是:</p>
<p>(1)乱序优化是编译器内部的一种实现手段,作为代码者,我完全没有必要知道这个.当然,如果我要了解这个也可以,但是让我在代码上保证这个就完全是&#8221;强人所难&#8221;.</p>
<p>(2)就我的知识,atomic operation不是保证避免乱序优化,而是为了保证原子状态的读写操作,在很大程度上是为了避免从缓存读写内容,而是从代价比较昂贵的内存读写.说明atomic operation最好的例子是两个线程对一个int型的变量累加的操作,如果不使用类似于atomic operation的操作,那么最后的结果可能是变量只是累加1,而不是累加2(因为是两个线程).</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=22#respond' onclick='return addComment.moveForm( "div-comment-22", "22", "respond", "367" )' aria-label='回复给zade'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-23" class="comment byuser comment-author-admin bypostauthor odd alt depth-2">
			<article id="div-comment-23" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn"><a href='http://www.parallellabs.com' rel='external nofollow' class='url'>G.C. Chen</a></b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-23">
							<time datetime="2010-03-09T10:35:12+00:00">
								03/09/2010 10:35							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>（1）确实这样给程序员造成了很大的困难，所以有一个简化的data race model被提出来，即只要保证acquire和release语义就能简化编程和编译器优化的难度，具体的你可以看看参考文献[6]。但是我想说，进入多核时代后不管是程序员还是compiler writer还是搞体系结构的都面临非常多的新挑战，现阶段不可能programmer什么都不需要做就可以免费的享受多核，阵痛是难免的。<br />
（2）我原文中对atomic operation只是一笔带过，近期会专门写一篇文章讲它，实际上atomic operation会有memory ordering的语义。</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=23#respond' onclick='return addComment.moveForm( "div-comment-23", "23", "respond", "367" )' aria-label='回复给G.C. Chen'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-28" class="comment byuser comment-author-admin bypostauthor even thread-odd thread-alt depth-1">
			<article id="div-comment-28" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn"><a href='http://www.parallellabs.com' rel='external nofollow' class='url'>G.C. Chen</a></b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-28">
							<time datetime="2010-03-22T20:03:38+00:00">
								03/22/2010 20:03							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>本文在Top Language的讨论可见：<br />
<a href="http://groups.google.com/group/pongba/browse_thread/thread/e0dd2f670d3657ed" rel="nofollow">为什么程序员需要关心Sequential Consistency而不是Cache Coherence？</a><br />
如果访问不了可以把http换成https试试</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=28#respond' onclick='return addComment.moveForm( "div-comment-28", "28", "respond", "367" )' aria-label='回复给G.C. Chen'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
		<li id="comment-44" class="pingback odd alt thread-even depth-1">
			<div class="comment-body">
				Pingback： <a href='http://www.parallellabs.com/2010/04/15/atomic-operation-in-multithreaded-application/' rel='external nofollow' class='url'>多线程程序中操作的原子性 | 并行实验室 | Parallel Labs</a> 			</div>
</li><!-- #comment-## -->
		<li id="comment-251" class="comment even thread-odd thread-alt depth-1">
			<article id="div-comment-251" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/927760702de5f075f09db06782ea0bb9?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/927760702de5f075f09db06782ea0bb9?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">ericliu</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-251">
							<time datetime="2010-11-09T06:54:36+00:00">
								11/09/2010 06:54							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>感谢博主的分享。Cache Coherence在动态生成二进制代码并执行的时候是需要关注的，例如Chunck技术。</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=251#respond' onclick='return addComment.moveForm( "div-comment-251", "251", "respond", "367" )' aria-label='回复给ericliu'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
		<li id="comment-252" class="comment odd alt thread-even depth-1 parent">
			<article id="div-comment-252" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/927760702de5f075f09db06782ea0bb9?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/927760702de5f075f09db06782ea0bb9?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">ericliu</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-252">
							<time datetime="2010-11-09T07:07:08+00:00">
								11/09/2010 07:07							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>另外，请教博主一个问题，乱序到底是指的哪种语义？<br />
1、CPU本身执行指令的时候是乱序执行的，但对于程序员来说其执行结果等价于按程序序依次执行指令的结果，从而对程序员透明。<br />
2、编译器编译优化的过程中根据CPU的流水线特征做了指令重排，在单个线程遵循程序序，但是由于不知道多线程运行环境，可能保证不了程序整体语义上的程序序，从而导致执行结果错误。</p>
<p>麻烦解释下这个困惑我很久的问题，多谢。</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=252#respond' onclick='return addComment.moveForm( "div-comment-252", "252", "respond", "367" )' aria-label='回复给ericliu'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-253" class="comment byuser comment-author-admin bypostauthor even depth-2">
			<article id="div-comment-253" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn"><a href='http://www.parallellabs.com' rel='external nofollow' class='url'>Guancheng Chen</a></b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-253">
							<time datetime="2010-11-11T07:43:02+00:00">
								11/11/2010 07:43							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>@ericliu<br />
就像你说的，乱序即有CPU造成的也有和编译器造成的。在传统的单线程语义下，CPU和编译器的乱序优化是不会影响程序语义的正确性的，所以对程序员来说就是透明的。但是在多线程环境下，因为CPU和编译器都缺少对多线程程序语义的“整体性”的了解，所以就可能造成违反多线程语义的错误的优化。说简单点，就是因为CPU和编译器还未能跟上多核时代的步伐。要保证正确性最简答的办法就是不做乱序优化，直接按照我文中所指的Sequential Consistency的方式顺序执行，可是这样对程序的性能影响太大，本质上CPU和编译器之所以要乱序执行就是为了提高性能。所以现在的折衷方案是由程序员来在适当的地方使用带有acquire和release的原语来“告诉”CPU和编译器你在这个地方不能给我做优化，其他的地方你可以做。Acquire和release语义的原语在内部会调用memory barrier来保证memory order。例如，VS2005开始所有<a href="http://msdn.microsoft.com/en-us/library/12a04hfd(VS.80).aspx" rel="nofollow">volatile变量</a>的读操作有acquire语义，写操作具有release语义。这个属性在C++标准里是没有的，属于VS自己的扩展。但是尽管如此，volatile在多线程里面还是非常难搞的一个概念，我会专门写一写它。</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=253#respond' onclick='return addComment.moveForm( "div-comment-253", "253", "respond", "367" )' aria-label='回复给Guancheng Chen'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-257" class="pingback odd alt thread-odd thread-alt depth-1">
			<div class="comment-body">
				Pingback： <a href='http://www.parallellabs.com/2010/11/13/concurrency-bugs-1/' rel='external nofollow' class='url'>多线程程序常见Bug剖析 | 并行实验室 | 并行实验室 | Parallel Labs</a> 			</div>
</li><!-- #comment-## -->
		<li id="comment-399" class="pingback even thread-even depth-1">
			<div class="comment-body">
				Pingback： <a href='http://www.parallellabs.com/2010/12/04/why-we-should-be-care-of-volatile-keyword-in-multithreaded-applications/' rel='external nofollow' class='url'>为什么在多线程程序中要慎用volatile关键字？ | 并行实验室 | Parallel Labs</a> 			</div>
</li><!-- #comment-## -->
		<li id="comment-719" class="comment odd alt thread-odd thread-alt depth-1 parent">
			<article id="div-comment-719" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c0ef74729de5c29dc1b73af1741549ad?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c0ef74729de5c29dc1b73af1741549ad?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-719">
							<time datetime="2011-04-22T17:56:43+00:00">
								04/22/2011 17:56							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>我不懂為什麼程序员会滿足于SC?上例Execution 1，Execution 2，Execution 3都滿足SC，但r1,r2结果都不一樣；有哪一個程序员会喜歡non-deterministic的结果？</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=719#respond' onclick='return addComment.moveForm( "div-comment-719", "719", "respond", "367" )' aria-label='回复给MKL'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-723" class="comment byuser comment-author-admin bypostauthor even depth-2 parent">
			<article id="div-comment-723" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn"><a href='http://www.parallellabs.com' rel='external nofollow' class='url'>Guancheng</a></b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-723">
							<time datetime="2011-04-24T11:11:21+00:00">
								04/24/2011 11:11							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>恩 non deterministic是Multicore的固有通病 而且是很多concurrency bug的根源。现在一个研究热点就是deterministic并行。</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=723#respond' onclick='return addComment.moveForm( "div-comment-723", "723", "respond", "367" )' aria-label='回复给Guancheng'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-728" class="comment odd alt depth-3">
			<article id="div-comment-728" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c0ef74729de5c29dc1b73af1741549ad?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c0ef74729de5c29dc1b73af1741549ad?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-728">
							<time datetime="2011-04-25T09:05:13+00:00">
								04/25/2011 09:05							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>所以你同意SC没有用? 要deterministic的结果就要加synchronization(wait, signal等)，加了synchronization就定了execution order，SC就无用武之地了！？</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=728#respond' onclick='return addComment.moveForm( "div-comment-728", "728", "respond", "367" )' aria-label='回复给MKL'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-730" class="comment even depth-2 parent">
			<article id="div-comment-730" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c0ef74729de5c29dc1b73af1741549ad?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c0ef74729de5c29dc1b73af1741549ad?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-730">
							<time datetime="2011-04-25T09:30:57+00:00">
								04/25/2011 09:30							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>My point is: In order to get deterministic result, one has to put in synchronization, and once sync is put in, one fixes the order of execution &#8211; at least the order which SC tries to re-arrange &#8211; and SC is rendered irrelevant; using SC or not, reordering is not allowed; no one can benefit from reordering.<br />
Look at the exmple.  If you want r1==0 and r2 == 1, then you can allow Exec 1 only, and you will write<br />
Thread 1 {<br />
x = 1;<br />
r1 = y;<br />
signal(sync)<br />
}<br />
Thread 2 {<br />
wait(sync)<br />
y = 1;<br />
r2 = x;<br />
}<br />
And yes, the compiler can still reorder (switch the order of) the 2 assignments in Thread 1, and the 2 assignments in Thread 2, though that&#8217;s not even allowed by SC.  But the orders of execution in Exec 2 and 3, allowed under SC, are no longer permitted once synchronization is added to ensure deterministic result.  Then what&#8217;s the use of SC?  And why does a programmer need to care about the consistency model?  Once synchronization is put in to ensure determinism, the execution order is pretty much fixed.</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=730#respond' onclick='return addComment.moveForm( "div-comment-730", "730", "respond", "367" )' aria-label='回复给MKL'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-746" class="comment byuser comment-author-admin bypostauthor odd alt depth-3 parent">
			<article id="div-comment-746" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn"><a href='http://www.parallellabs.com' rel='external nofollow' class='url'>Guancheng</a></b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-746">
							<time datetime="2011-05-01T16:26:20+00:00">
								05/01/2011 16:26							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>Good point.<br />
我同意你的观点：从程序员的角度来讲，为了保证r1，r2的最终值是确定的，程序员会使用synchronization来使得程序按自己的意志来进行。其实这就是编写多线程程序时的一条关键准则：任何时候都不能假定你的程序会按照你所想的执行顺序去执行（因为execution order是不确定的），而是需要使用synchronization来确保程序会按你所想的方式去执行。</p>
<p>至于SC，它之所以有用是因为JDK1.5和C++ 1x的多线程内存模型中就引入了SC for data race free这个模型。基于这个模型，在进行lock free编程的时候程序员就特别需要注意memory consistency相关的概念（因为这时体现在代码上的就不是经常用的lock，conditional variable等开销很大的同步机制，而是带有原子性和顺序性语义的atomic变量了）。希望我这个解释能让你满意:)</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=746#respond' onclick='return addComment.moveForm( "div-comment-746", "746", "respond", "367" )' aria-label='回复给Guancheng'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-758" class="comment even depth-4">
			<article id="div-comment-758" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-758">
							<time datetime="2011-05-05T15:11:40+00:00">
								05/05/2011 15:11							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>不满意:) &#8220;SC&#8230;有用是因为&#8230;进行lock free编程的时候程序员就特别需要注意memory consistency相关的概念&#8221; 我说过，你也同意，程序员会使用synchronization来确保determinism。那为何又会进行lock free编程呢？你有不用lock也可确保determinism、correctness的程序例子吗？“atomic变量”其实是不是一个syntactic sugar? 把一个变量declare為“atomic variable”其实不就是每一次access它的时候都加mutex lock? 在program中每一次access它的时候都加mutex lock太麻烦，所以便弄了“atomic”这个data type，为程序员save some trouble.</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=758#respond' onclick='return addComment.moveForm( "div-comment-758", "758", "respond", "367" )' aria-label='回复给MKL'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
		<li id="comment-765" class="comment odd alt depth-4 parent">
			<article id="div-comment-765" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-765">
							<time datetime="2011-05-06T12:17:32+00:00">
								05/06/2011 12:17							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>&#8220;SC有用是因为SC for data race free这个模型&#8221; &#8211; SC 在 SC for data race free这个模型 出现前很久就有了。所以在 SC for data race free这个模型 出现前，SC是没用的？有人没事做，搞一个SC出来；十几/几十年后，搞SC for data race free模型的时候才发觉SC的用处？？？<br />
BTW, data race和data dependence分别在那？</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=765#respond' onclick='return addComment.moveForm( "div-comment-765", "765", "respond", "367" )' aria-label='回复给MKL'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-766" class="comment even depth-5">
			<article id="div-comment-766" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-766">
							<time datetime="2011-05-06T17:00:09+00:00">
								05/06/2011 17:00							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>What I actually meant to ask is: Can data race be determined by data dependence?</p>
				</div><!-- .comment-content -->

							</article><!-- .comment-body -->
</li><!-- #comment-## -->
		<li id="comment-787" class="comment byuser comment-author-admin bypostauthor odd alt depth-5">
			<article id="div-comment-787" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn"><a href='http://www.parallellabs.com' rel='external nofollow' class='url'>Guancheng</a></b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-787">
							<time datetime="2011-05-15T21:02:51+00:00">
								05/15/2011 21:02							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>呵呵，“SC有用是因为SC for data race free这个模型”这句话确实不严谨。我举个例子吧，在C++1x中，程序员可以对atomic类型的操作制定三种不同类型的memory ordering：sequential consistent ordering，acquire release ordering和relaxed ordering。atomic类型比mutex提供了更大的灵活性（例如可以用atomic类型实现lock free算法），两者不可同日而语。如果程序员对这三种ordering的特点不了解的话就不能很好的使用atomic类型，这直接证明了为什么程序员需要了解SC。</p>
				</div><!-- .comment-content -->

							</article><!-- .comment-body -->
</li><!-- #comment-## -->
		<li id="comment-795" class="comment even depth-5">
			<article id="div-comment-795" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-795">
							<time datetime="2011-05-20T13:39:06+00:00">
								05/20/2011 13:39							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>言下之意就是如果没有C++1x的memory ordering，就没有必要了解SC? 首先说“SC有用是因为SC for data race free这个模型”，现在又好像说SC有用是因为C++1x的memory ordering，究竟SC可不可以有自己的用处？</p>
				</div><!-- .comment-content -->

							</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-731" class="comment odd alt thread-even depth-1 parent">
			<article id="div-comment-731" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c0ef74729de5c29dc1b73af1741549ad?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c0ef74729de5c29dc1b73af1741549ad?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-731">
							<time datetime="2011-04-25T11:16:07+00:00">
								04/25/2011 11:16							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>我想讲清楚我讲的deterministic是指final values of r1 and r2不是指execution order.</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=731#respond' onclick='return addComment.moveForm( "div-comment-731", "731", "respond", "367" )' aria-label='回复给MKL'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-756" class="comment even depth-2">
			<article id="div-comment-756" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://1.gravatar.com/avatar/73c1ebfea948c0d15ce01c1c49e50973?s=42&#038;r=g' srcset='http://1.gravatar.com/avatar/73c1ebfea948c0d15ce01c1c49e50973?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">hayate</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-756">
							<time datetime="2011-05-04T14:24:02+00:00">
								05/04/2011 14:24							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>其实到处都有non-deterministic的现象啊，比如抢占式操作系统，你并不关心某个进程何时分到了多大的时间片；比如windows消息机制，你并不在乎程序一定的情况下消息是否按照某个顺序到达。SC是个基本的保证，即使加了同步语义，程序的结果是deterministic，仍然包含在SC的框架下了</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=756#respond' onclick='return addComment.moveForm( "div-comment-756", "756", "respond", "367" )' aria-label='回复给hayate'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-759" class="comment odd alt thread-odd thread-alt depth-1 parent">
			<article id="div-comment-759" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-759">
							<time datetime="2011-05-05T15:24:13+00:00">
								05/05/2011 15:24							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>&#8220;其实到处都有non-deterministic的现象&#8221;- I agree, but that&#8217;s not my point.  Programmers do not like non-deterministic output (i.e. final values), so they use synchronization to ensure determinism.  &#8220;SC是个基本的保证&#8221; &#8211; 保证什么呢？保证determinism吗？文中已有例子说明SC不保证determinism！Synchronization才是保证determinism。我不知道你的“SC框架”是什么框架。有了Synchronization保证determinism，再搞一个“SC框架”不是多此一举吗？</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=759#respond' onclick='return addComment.moveForm( "div-comment-759", "759", "respond", "367" )' aria-label='回复给MKL'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-760" class="comment even depth-2">
			<article id="div-comment-760" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-760">
							<time datetime="2011-05-05T15:46:59+00:00">
								05/05/2011 15:46							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>A consistency model limits the values of a variables from a read. In the example in the article, (r1,r2) can be at least (0,1),(1,0),(1,1),(0,0). But SC limits the set of possible values to be the first three pairs only.  A relaxed model may allow all 4 possibilities.  My point is:  A programmer in 99% of the cases would like only one possibility； so he uses synchronization.  Once synchronization is used, the consistency model is irrelevant.  Then why care about what consistency model is used and what possibilities there are?  And I think that&#8217;s why most parallel programming languages do not specify a consistency model.  Now Java and C++ are trying to specify one &#8211; is it only because that they have these volatile and atomic variables?  Then, if they don&#8217;t have these data types, does it mean a consistency model is not needed?  And are these data types really needed?  Or because there are emerging applications that permit non-determinism?</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=760#respond' onclick='return addComment.moveForm( "div-comment-760", "760", "respond", "367" )' aria-label='回复给MKL'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-880" class="comment odd alt thread-even depth-1">
			<article id="div-comment-880" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/fa947d318227c17e3f7f695686cfa75e?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/fa947d318227c17e3f7f695686cfa75e?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">Terrence</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-880">
							<time datetime="2011-07-01T08:59:47+00:00">
								07/01/2011 08:59							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>1)Synchronization本身的实现就是需要考虑SC的，换句话说，如果没有SC，Synchronization都根本实现不了，所以说操作系统编写人员在SC的基础上，实现了一整套Synchronization供应用程序开发人员调用；<br />
2)对于95%以上的程序员实际上都可以用Synchronization取代关键代码端SC的MB操作，但仍然有一些程序员在考虑性能终极优化的时候需要深入了解SC，比如一些核心服务器报文转发，如果收到报文就掉Synchronization，那整体性能会非常差，SC可以在这个层面保证吞吐量和最佳的性能。目前一些云计算的一些程序都再用SC取代Synchronization了。</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=880#respond' onclick='return addComment.moveForm( "div-comment-880", "880", "respond", "367" )' aria-label='回复给Terrence'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
		<li id="comment-1067" class="comment even thread-odd thread-alt depth-1">
			<article id="div-comment-1067" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c86968f5d833ebb45434000eb6913160?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">MKL</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-1067">
							<time datetime="2011-07-23T13:28:46+00:00">
								07/23/2011 13:28							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>&#8220;用Synchronization取代关键代码端SC的Memory Barrier操作&#8221; &#8212; Synchronization的定義為何？SC的MB操作指何？ Process （or thread） synchronization construct 很多都imply有 data synchronization (e.g. Memory Barrier)。  OpenMP的&#8221;end parallel&#8221; directive就imply memory barrier。那不是“取代”。</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=1067#respond' onclick='return addComment.moveForm( "div-comment-1067", "1067", "respond", "367" )' aria-label='回复给MKL'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
		<li id="comment-1070" class="comment odd alt thread-even depth-1 parent">
			<article id="div-comment-1070" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://1.gravatar.com/avatar/1cef997ca4e68a83a66c7494afb31600?s=42&#038;r=g' srcset='http://1.gravatar.com/avatar/1cef997ca4e68a83a66c7494afb31600?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">fish</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-1070">
							<time datetime="2011-07-25T11:51:45+00:00">
								07/25/2011 11:51							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>最近一直对memory barrier 非常疑惑，由于最近在写多线程服务器。我想问下我的理解是否正确<br />
1。Memory barrier是用来保证SC的而不是用来刷新CPU Cache到内存的<br />
2。一个核上的线程对某个内存的操作不需要显示调用MB等操作也能在其他核上运行的线程的读操作<br />
反应出来（这是通过文章中所说的CC协议所保证的，是对程序员透明的）<br />
3。如果有这样2个线程，<br />
   bool continuerun = true;<br />
   线程1<br />
   while(continuerun)<br />
   {<br />
     &#8230;do something<br />
   }<br />
   线程2<br />
   while(1)<br />
   {<br />
      if（如果用户输入exit）<br />
          continuerun = false;<br />
   }</p>
<p>对于这样一个程序，如果用户输入exit以后，continuerun的变量改变会在另外一个线程中立即反应出来（由CPu的CC协议保证）<br />
是这样么</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=1070#respond' onclick='return addComment.moveForm( "div-comment-1070", "1070", "respond", "367" )' aria-label='回复给fish'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-1368" class="comment even depth-2 parent">
			<article id="div-comment-1368" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/83bd52f3ff77dc7c91c0615157bc8111?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/83bd52f3ff77dc7c91c0615157bc8111?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">digdeep</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-1368">
							<time datetime="2011-11-10T20:25:03+00:00">
								11/10/2011 20:25							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>个人观点，仅供参考：<br />
1.Memory barrier是用来保证SC的而不是用来刷新CPU Cache到内存的。这一点肯定是对的。<br />
2.关于第二点和第三点显然不对。“一个核上的线程对某个内存的操作不需要显示调用MB等操作也能在其他核上运行的线程的读操作反应出来” &#8212; 那我们还要“锁”干嘛！<br />
3. &#8220;2个线程&#8221;的编码应该为：<br />
bool continuerun = true;<br />
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br />
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;<br />
线程1<br />
pthread_mutex_lock(&amp;lock);<br />
while(continuerun)<br />
{<br />
…do something<br />
pthread_cond_wait(&amp;cond, &amp;lock);<br />
…do something<br />
}<br />
线程2<br />
while(1)<br />
{<br />
if（如果用户输入exit）{<br />
pthread_mutex_lock(&amp;lock);<br />
continuerun = false;<br />
pthread_cond_signal(&amp;cond);<br />
pthread_mutex_unlock(&amp;lock);<br />
}<br />
}</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=1368#respond' onclick='return addComment.moveForm( "div-comment-1368", "1368", "respond", "367" )' aria-label='回复给digdeep'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-7512" class="comment odd alt depth-3 parent">
			<article id="div-comment-7512" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/c453069a9ed0f9a810f979373ccfb8ae?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/c453069a9ed0f9a810f979373ccfb8ae?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">daniel</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-7512">
							<time datetime="2013-08-15T17:50:14+00:00">
								08/15/2013 17:50							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>不好意思，看您回答说第二点肯定不对，但是从博主这篇文章中“<br />
。Cache Coherence（下文简称CC）是多核CPU在硬件中已经实现的一种机制，简单的说，它确保了对在多核CPU的Cache中一个地址的读操作一定会返回那个地址最新的（被写入）的值。<br />
”<br />
感觉第二点也是对的啊，请博主也发表一下意见，谢谢</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=7512#respond' onclick='return addComment.moveForm( "div-comment-7512", "7512", "respond", "367" )' aria-label='回复给daniel'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-7555" class="comment byuser comment-author-admin bypostauthor even depth-4 parent">
			<article id="div-comment-7555" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn"><a href='http://www.parallellabs.com' rel='external nofollow' class='url'>Guancheng</a></b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-7555">
							<time datetime="2013-08-18T16:48:53+00:00">
								08/18/2013 16:48							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>digdeep说的一定要用mutex是对的。</p>
<p>“Cache Coherence（下文简称CC）是多核CPU在硬件中已经实现的一种机制，简单的说，它确保了对在多核CPU的Cache中一个地址的读操作一定会返回那个地址最新的（被写入）的值。”，这句话没错，但是在程序中，continuerun这个被线程1写入的新值一定在线程2读到之前就“真正被写入到cache里”，而不是暂时缓存在cache buffer之类的地方，是需要用锁来保证的。两者是两个维度的问题。</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=7555#respond' onclick='return addComment.moveForm( "div-comment-7555", "7555", "respond", "367" )' aria-label='回复给Guancheng'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-36929" class="comment odd alt depth-5">
			<article id="div-comment-36929" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/bbfe855fa5296821fbadacce95c68bd7?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/bbfe855fa5296821fbadacce95c68bd7?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">kamimail</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-36929">
							<time datetime="2014-08-17T19:04:03+00:00">
								08/17/2014 19:04							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>博主，你好，你在回复中提到“continuerun这个被线程1写入的新值一定在线程2读到之前就“真正被写入到cache里”，而不是暂时缓存在cache buffer之类的地方，是需要用锁来保证的”，CACHE和CACHE BUFFER各指什么？难道他们不是CPU中的L2么？</p>
				</div><!-- .comment-content -->

							</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-1394" class="comment even depth-2">
			<article id="div-comment-1394" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/83bd52f3ff77dc7c91c0615157bc8111?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/83bd52f3ff77dc7c91c0615157bc8111?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">digdeep</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-1394">
							<time datetime="2011-11-11T11:21:43+00:00">
								11/11/2011 11:21							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>在网上查到一片英文资料，刚好可以回答你的第2、3个问题：http://www.cs.nmsu.edu/~pfeiffer/classes/573/notes/consistency.html<br />
Cache Coherence：<br />
Most authors treat cache coherence as being virtually synonymous with sequential consistency; it is perhaps surprising that it isn&#8217;t. Sequential consistency requires a globally (i.e. across all memory locations) consistent view of memory operations, cache coherence only requires a locally (i.e. per-location) consistent view. Here&#8217;s an example of a scenario that would be valid under cache coherence but not sequential consistency:<br />
P1:  W(x)1 W(y)2<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
P2:        R(x)0 R(x)2 R(x)1 R(y)0 R(y)1<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
P3:        R(y)0 R(y)1 R(x)0 R(x)1<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
P4: W(x)2 W(y)1<br />
这里有四个进程（线程）P1和P4对x,y进行写操作，而P2和P3对x,y进行读操作。我们可以看到：在P1和P4对x进行写操作之后，P2最先读到的x=0；在P1和P4对y进行写操作之后，P2和P3竟然从来没有读到y=2的情况。所以说：在程序员的头脑中最好忘掉“CC”，“CC”与我们程序员没有半毛钱的直接关系。<br />
注：这里P2和P3看到的“执行顺序”不一致，所以它违反了“SC”！</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=1394#respond' onclick='return addComment.moveForm( "div-comment-1394", "1394", "respond", "367" )' aria-label='回复给digdeep'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-1395" class="comment odd alt thread-odd thread-alt depth-1 parent">
			<article id="div-comment-1395" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/83bd52f3ff77dc7c91c0615157bc8111?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/83bd52f3ff77dc7c91c0615157bc8111?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">digdeep</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-1395">
							<time datetime="2011-11-11T11:28:26+00:00">
								11/11/2011 11:28							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>NND，格式发生了变化，补充一下：<br />
P1: W(x)1 W(y)2<br />
———————–———————–———————–———————–———————–<br />
P2:       R(x)0 R(x)2 R(x)1 R(y)0 R(y)1<br />
———————–———————–———————–———————–———————–<br />
P3:       R(y)0 R(y)1 R(x)0 R(x)1<br />
———————–———————–———————–———————–———————–<br />
P4: W(x)2 W(y)1</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=1395#respond' onclick='return addComment.moveForm( "div-comment-1395", "1395", "respond", "367" )' aria-label='回复给digdeep'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-1396" class="comment even depth-2 parent">
			<article id="div-comment-1396" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/83bd52f3ff77dc7c91c0615157bc8111?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/83bd52f3ff77dc7c91c0615157bc8111?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">digdeep</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-1396">
							<time datetime="2011-11-11T11:34:07+00:00">
								11/11/2011 11:34							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>还是不行，“P2：”和“P3：”后面的三个空格被系统自动删除了。又不能发图片。还是参考原网站吧：http://www.cs.nmsu.edu/~pfeiffer/classes/573/notes/consistency.html</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=1396#respond' onclick='return addComment.moveForm( "div-comment-1396", "1396", "respond", "367" )' aria-label='回复给digdeep'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-1508" class="comment byuser comment-author-admin bypostauthor odd alt depth-3">
			<article id="div-comment-1508" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn"><a href='http://www.parallellabs.com' rel='external nofollow' class='url'>Guancheng</a></b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-1508">
							<time datetime="2011-11-28T08:32:09+00:00">
								11/28/2011 08:32							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>抱歉回复里没有html编辑功能，回头我找个插件装上看看。</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=1508#respond' onclick='return addComment.moveForm( "div-comment-1508", "1508", "respond", "367" )' aria-label='回复给Guancheng'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-1788" class="comment even thread-even depth-1 parent">
			<article id="div-comment-1788" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/9a8f0dc61c888cff2cd2cd98e254e7ba?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/9a8f0dc61c888cff2cd2cd98e254e7ba?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn"><a href='http://people.cs.nctu.edu.tw/~chenwj' rel='external nofollow' class='url'>chenwj</a></b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-1788">
							<time datetime="2012-02-06T17:35:25+00:00">
								02/06/2012 17:35							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>&#8220;在进入多核时代后编译器没跟上发展&#8221; 對於這句話我要發點聲。這根源應該在於語言要先訂出記憶體模型，而後編譯器才能依照語言規定進行優化。說编译器没跟上发展有點冤枉它了。:)</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=1788#respond' onclick='return addComment.moveForm( "div-comment-1788", "1788", "respond", "367" )' aria-label='回复给chenwj'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-1829" class="comment byuser comment-author-admin bypostauthor odd alt depth-2">
			<article id="div-comment-1829" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=42&#038;r=g' srcset='http://2.gravatar.com/avatar/e27fcc4ef08dcf8129f6dd3eb1bfa8ce?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn"><a href='http://www.parallellabs.com' rel='external nofollow' class='url'>Guancheng</a></b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-1829">
							<time datetime="2012-03-02T10:54:27+00:00">
								03/02/2012 10:54							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>同意:)</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=1829#respond' onclick='return addComment.moveForm( "div-comment-1829", "1829", "respond", "367" )' aria-label='回复给Guancheng'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-2009" class="pingback even thread-odd thread-alt depth-1">
			<div class="comment-body">
				Pingback： <a href='http://www.huangdong.name/?p=28' rel='external nofollow' class='url'>多线程程序中操作的原子性 | 废墟</a> 			</div>
</li><!-- #comment-## -->
		<li id="comment-2885" class="comment odd alt thread-even depth-1">
			<article id="div-comment-2885" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://0.gravatar.com/avatar/6bebebc8992cbde9197e806930069b24?s=42&#038;r=g' srcset='http://0.gravatar.com/avatar/6bebebc8992cbde9197e806930069b24?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">贺亮</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-2885">
							<time datetime="2012-11-29T18:07:49+00:00">
								11/29/2012 18:07							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>我最近在写多线程的程序时，对C++ 的关键字volatile 非常的不解，很多人说在多个线程共享的变量前都在加这个，但你又说不用去理会CC，我真是晕头了。</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=2885#respond' onclick='return addComment.moveForm( "div-comment-2885", "2885", "respond", "367" )' aria-label='回复给贺亮'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
		<li id="comment-5755" class="comment even thread-odd thread-alt depth-1 parent">
			<article id="div-comment-5755" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://1.gravatar.com/avatar/aee3165ebbce13da25f6d168d9f84dd2?s=42&#038;r=g' srcset='http://1.gravatar.com/avatar/aee3165ebbce13da25f6d168d9f84dd2?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">Michael</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-5755">
							<time datetime="2013-05-06T00:00:00+00:00">
								05/06/2013 00:00							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>楼主，似乎 Cache Conherence （缓存一致性）应该是Cache Coherency？</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=5755#respond' onclick='return addComment.moveForm( "div-comment-5755", "5755", "respond", "367" )' aria-label='回复给Michael'>回复</a></div>			</article><!-- .comment-body -->
<ol class="children">
		<li id="comment-5756" class="comment odd alt depth-2">
			<article id="div-comment-5756" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt='' src='http://1.gravatar.com/avatar/aee3165ebbce13da25f6d168d9f84dd2?s=42&#038;r=g' srcset='http://1.gravatar.com/avatar/aee3165ebbce13da25f6d168d9f84dd2?s=84&amp;r=g 2x' class='avatar avatar-42 photo' height='42' width='42' />						<b class="fn">Michael</b><span class="says">说道：</span>					</div><!-- .comment-author -->

					<div class="comment-metadata">
						<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#comment-5756">
							<time datetime="2013-05-06T00:05:42+00:00">
								05/06/2013 00:05							</time>
						</a>
											</div><!-- .comment-metadata -->

									</footer><!-- .comment-meta -->

				<div class="comment-content">
					<p>哦，仅是一个笔误而已，无关大局，我反倒自己不看前面其实是正确的</p>
				</div><!-- .comment-content -->

				<div class="reply"><a rel='nofollow' class='comment-reply-link' href='http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/?replytocom=5756#respond' onclick='return addComment.moveForm( "div-comment-5756", "5756", "respond", "367" )' aria-label='回复给Michael'>回复</a></div>			</article><!-- .comment-body -->
</li><!-- #comment-## -->
</ol><!-- .children -->
</li><!-- #comment-## -->
		<li id="comment-27345" class="pingback even thread-even depth-1">
			<div class="comment-body">
				Pingback： <a href='http://blog.makaidong.com/21261.html' rel='external nofollow' class='url'>多线程程序中操作的原子性 &#8211; 马开东博客</a> 			</div>
</li><!-- #comment-## -->
		<li id="comment-30048" class="pingback odd alt thread-odd thread-alt depth-1">
			<div class="comment-body">
				Pingback： <a href='http://makaidong.com/2083.html' rel='external nofollow' class='url'>多线程程序中操作的原子性 - IT牛人博客聚合</a> 			</div>
</li><!-- #comment-## -->
		<li id="comment-62637" class="pingback even thread-even depth-1">
			<div class="comment-body">
				Pingback： <a href='http://www.havebug.com/archives/10978.html' rel='external nofollow' class='url'>浅谈消息队列 - 有Bug</a> 			</div>
</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		
	
	
		<div id="respond" class="comment-respond">
		<h2 id="reply-title" class="comment-reply-title">发表评论 <small><a rel="nofollow" id="cancel-comment-reply-link" href="/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/#respond" style="display:none;">取消回复</a></small></h2>			<form action="http://www.parallellabs.com/wp-comments-post.php" method="post" id="commentform" class="comment-form" novalidate>
				<p class="comment-notes"><span id="email-notes">电子邮件地址不会被公开。</span> 必填项已用<span class="required">*</span>标注</p><p class="comment-form-comment"><label for="comment">评论</label> <textarea id="comment" name="comment" cols="45" rows="8" maxlength="65525" aria-required="true" required="required"></textarea></p><p class="comment-form-author"><label for="author">姓名 <span class="required">*</span></label> <input id="author" name="author" type="text" value="" size="30" maxlength="245" aria-required='true' required='required' /></p>
<p class="comment-form-email"><label for="email">电子邮件 <span class="required">*</span></label> <input id="email" name="email" type="email" value="" size="30" maxlength="100" aria-describedby="email-notes" aria-required='true' required='required' /></p>
<p class="comment-form-url"><label for="url">站点</label> <input id="url" name="url" type="url" value="" size="30" maxlength="200" /></p>
<p class="form-submit"><input name="submit" type="submit" id="submit" class="submit" value="发表评论" /> <input type='hidden' name='comment_post_ID' value='367' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
</p><p style="display: none;"><input type="hidden" id="akismet_comment_nonce" name="akismet_comment_nonce" value="b65acbb8b1" /></p><p style="display: none;"><input type="hidden" id="ak_js" name="ak_js" value="213"/></p>			</form>
			</div><!-- #respond -->
	
</div><!-- .comments-area -->

	<nav class="navigation post-navigation" role="navigation">
		<h2 class="screen-reader-text">文章导航</h2>
		<div class="nav-links"><div class="nav-previous"><a href="http://www.parallellabs.com/2010/02/18/8-simple-rules-for-designing-multithreaded-applications/" rel="prev"><span class="meta-nav" aria-hidden="true">上一</span> <span class="screen-reader-text">上篇文章：</span> <span class="post-title">八条设计多线程程序的简单规则</span></a></div><div class="nav-next"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" rel="next"><span class="meta-nav" aria-hidden="true">下一</span> <span class="screen-reader-text">下篇文章：</span> <span class="post-title">实施并行编程的五大障碍</span></a></div></div>
	</nav>
	</main><!-- .site-main -->

	
</div><!-- .content-area -->


	<aside id="secondary" class="sidebar widget-area" role="complementary">
		<section id="pages-3" class="widget widget_pages"><h2 class="widget-title">页面</h2>		<ul>
			<li class="page_item page-item-2"><a href="http://www.parallellabs.com/about/">About</a></li>
<li class="page_item page-item-516"><a href="http://www.parallellabs.com/blog/">Blog</a></li>
<li class="page_item page-item-919"><a href="http://www.parallellabs.com/message/">Message</a></li>
<li class="page_item page-item-352"><a href="http://www.parallellabs.com/quote/">Quote</a></li>
<li class="page_item page-item-1119"><a href="http://www.parallellabs.com/research/">Research</a></li>
		</ul>
		</section><section id="text-6" class="widget widget_text">			<div class="textwidget"><iframe width="100%" height="380" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=380&fansRow=1&ptype=1&speed=0&skin=2&isTitle=0&noborder=1&isWeibo=1&isFans=1&uid=1730295057&verifier=464b6df3&dpc=1"></iframe></div>
		</section><section id="categories-3" class="widget widget_categories"><h2 class="widget-title">分类目录</h2>		<ul>
	<li class="cat-item cat-item-29"><a href="http://www.parallellabs.com/category/review/" >业界评论</a>
</li>
	<li class="cat-item cat-item-78"><a href="http://www.parallellabs.com/category/%e5%a4%a7%e6%95%b0%e6%8d%ae/" >大数据</a>
</li>
	<li class="cat-item cat-item-2"><a href="http://www.parallellabs.com/category/parallel-programming/" >并行编程</a>
</li>
	<li class="cat-item cat-item-15"><a href="http://www.parallellabs.com/category/performance-analysis/" >性能分析</a>
</li>
	<li class="cat-item cat-item-1"><a href="http://www.parallellabs.com/category/uncategorized/" >未分类</a>
</li>
	<li class="cat-item cat-item-36"><a href="http://www.parallellabs.com/category/life/" >生活笔记</a>
</li>
	<li class="cat-item cat-item-9"><a href="http://www.parallellabs.com/category/algorithm-study/" >算法学习</a>
</li>
	<li class="cat-item cat-item-43"><a href="http://www.parallellabs.com/category/system-architecture/" >系统架构</a>
</li>
	<li class="cat-item cat-item-25"><a href="http://www.parallellabs.com/category/career/" >职业生涯</a>
</li>
		</ul>
</section>		<section id="recent-posts-4" class="widget widget_recent_entries">		<h2 class="widget-title">近期文章</h2>		<ul>
					<li>
				<a href="http://www.parallellabs.com/2016/04/04/cambricon-hiring/">人工智能芯片公司招聘工程师/行政/出纳</a>
						</li>
					<li>
				<a href="http://www.parallellabs.com/2016/03/29/druid-1st-meetup/">Druid中国用户组第一次线下技术交流资料分享</a>
						</li>
					<li>
				<a href="http://www.parallellabs.com/2015/06/29/thank-you-from-gc-guancheng-chen/">Thank you from G.C. Guancheng Chen</a>
						</li>
					<li>
				<a href="http://www.parallellabs.com/2015/06/03/disruptive-innovation/">怎样做颠覆式创新?</a>
						</li>
					<li>
				<a href="http://www.parallellabs.com/2015/05/12/supervessel-spark-as-a-service-with-openstack-and-docker/">基于OpenStack, Docker和Spark打造SuperVessel大数据公有云</a>
						</li>
				</ul>
		</section>		<section id="text-4" class="widget widget_text">			<div class="textwidget"><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />
<p></p>

<a href="http://www.prchecker.info/" title="Google PageRank Checker" target="_blank">
<img src="http://pr.prchecker.info/getpr.php?codex=aHR0cDovL3d3dy5wYXJhbGxlbGxhYnMuY29t&tag=1" alt="Google PageRank Checker" style="border:0;" /></a><p></p>
<a href="http://www.parallellabs.com/wp-admin/"  target="_blank">登录</a>

本博客所有内容仅代表作者个人意见，不代表IBM的观点。</div>
		</section><section id="rss-4" class="widget widget_rss"><h2 class="widget-title"><a class="rsswidget" href="http://www.parallellabs.com/feed"><img class="rss-widget-icon" style="border:0" width="14" height="14" src="http://parallellabs.qiniudn.com/wp-includes/images/rss.png" alt="RSS" /></a> <a class="rsswidget" href="http://www.parallellabs.com/">Parallel Labs</a></h2><ul><li><a class='rsswidget' href='http://www.parallellabs.com/2016/04/04/cambricon-hiring/'>人工智能芯片公司招聘工程师/行政/出纳</a></li><li><a class='rsswidget' href='http://www.parallellabs.com/2016/03/29/druid-1st-meetup/'>Druid中国用户组第一次线下技术交流资料分享</a></li><li><a class='rsswidget' href='http://www.parallellabs.com/2015/06/29/thank-you-from-gc-guancheng-chen/'>Thank you from G.C. Guancheng Chen</a></li><li><a class='rsswidget' href='http://www.parallellabs.com/2015/06/03/disruptive-innovation/'>怎样做颠覆式创新?</a></li><li><a class='rsswidget' href='http://www.parallellabs.com/2015/05/12/supervessel-spark-as-a-service-with-openstack-and-docker/'>基于OpenStack, Docker和Spark打造SuperVessel大数据公有云</a></li><li><a class='rsswidget' href='http://www.parallellabs.com/2015/04/11/vim-syntax-highlight-for-scala/'>给Vim配置Scala语法高亮显示</a></li><li><a class='rsswidget' href='http://www.parallellabs.com/2014/08/05/how-to-contribute-to-spark-step-by-step/'>一步一步教你怎样给Apache Spark贡献代码</a></li><li><a class='rsswidget' href='http://www.parallellabs.com/2014/05/03/value-of-big-data/'>大数据的价值密度</a></li><li><a class='rsswidget' href='http://www.parallellabs.com/2014/03/11/crl-bigdataclould-job/'>IBM研究院（CRL）诚聘 Bigdata/Clould 方向正式员工</a></li><li><a class='rsswidget' href='http://www.parallellabs.com/2013/09/22/my-way/'>My Way</a></li></ul></section><section id="recent-comments-3" class="widget widget_recent_comments"><h2 class="widget-title">近期评论</h2><ul id="recentcomments"><li class="recentcomments"><span class="comment-author-link">JackPy</span>发表在《<a href="http://www.parallellabs.com/2010/04/15/atomic-operation-in-multithreaded-application/comment-page-1/#comment-65258">多线程程序中操作的原子性</a>》</li><li class="recentcomments"><span class="comment-author-link"><a href='http://www.yameimei.356688.com/' rel='external nofollow' class='url'>yameimei</a></span>发表在《<a href="http://www.parallellabs.com/2015/06/29/thank-you-from-gc-guancheng-chen/comment-page-1/#comment-65104">Thank you from G.C. Guancheng Chen</a>》</li><li class="recentcomments"><span class="comment-author-link"><a href='http://www.yun.356688.com/' rel='external nofollow' class='url'>yun</a></span>发表在《<a href="http://www.parallellabs.com/2015/06/29/thank-you-from-gc-guancheng-chen/comment-page-1/#comment-65103">Thank you from G.C. Guancheng Chen</a>》</li><li class="recentcomments"><span class="comment-author-link"><a href='http://weibo.com/1344510244' rel='external nofollow' class='url'>鱼根猫</a></span>发表在《<a href="http://www.parallellabs.com/2015/06/29/thank-you-from-gc-guancheng-chen/comment-page-1/#comment-65101">Thank you from G.C. Guancheng Chen</a>》</li><li class="recentcomments"><span class="comment-author-link"><a href='http://weibo.com/1734261305' rel='external nofollow' class='url'>王子锐_Rogerwong</a></span>发表在《<a href="http://www.parallellabs.com/2015/06/29/thank-you-from-gc-guancheng-chen/comment-page-1/#comment-65102">Thank you from G.C. Guancheng Chen</a>》</li></ul></section><section id="tag_cloud-4" class="widget widget_tag_cloud"><h2 class="widget-title">标签</h2><div class="tagcloud"><a href="http://www.parallellabs.com/tag/algorithm/" class="tag-cloud-link tag-link-10 tag-link-position-1" style="font-size: 1em;">Algorithm</a>
<a href="http://www.parallellabs.com/tag/architecture/" class="tag-cloud-link tag-link-45 tag-link-position-2" style="font-size: 1em;">Architecture</a>
<a href="http://www.parallellabs.com/tag/big-data/" class="tag-cloud-link tag-link-59 tag-link-position-3" style="font-size: 1em;">Big Data</a>
<a href="http://www.parallellabs.com/tag/c1x/" class="tag-cloud-link tag-link-54 tag-link-position-4" style="font-size: 1em;">C++1x</a>
<a href="http://www.parallellabs.com/tag/chalmers/" class="tag-cloud-link tag-link-7 tag-link-position-5" style="font-size: 1em;">Chalmers</a>
<a href="http://www.parallellabs.com/tag/ericsson/" class="tag-cloud-link tag-link-26 tag-link-position-6" style="font-size: 1em;">Ericsson</a>
<a href="http://www.parallellabs.com/tag/erlang/" class="tag-cloud-link tag-link-42 tag-link-position-7" style="font-size: 1em;">Erlang</a>
<a href="http://www.parallellabs.com/tag/facebook/" class="tag-cloud-link tag-link-53 tag-link-position-8" style="font-size: 1em;">facebook</a>
<a href="http://www.parallellabs.com/tag/google/" class="tag-cloud-link tag-link-44 tag-link-position-9" style="font-size: 1em;">Google</a>
<a href="http://www.parallellabs.com/tag/hadoop/" class="tag-cloud-link tag-link-52 tag-link-position-10" style="font-size: 1em;">hadoop</a>
<a href="http://www.parallellabs.com/tag/ibm/" class="tag-cloud-link tag-link-55 tag-link-position-11" style="font-size: 1em;">ibm</a>
<a href="http://www.parallellabs.com/tag/internship/" class="tag-cloud-link tag-link-56 tag-link-position-12" style="font-size: 1em;">internship</a>
<a href="http://www.parallellabs.com/tag/interview/" class="tag-cloud-link tag-link-23 tag-link-position-13" style="font-size: 1em;">Interview</a>
<a href="http://www.parallellabs.com/tag/jobs/" class="tag-cloud-link tag-link-39 tag-link-position-14" style="font-size: 1em;">jobs</a>
<a href="http://www.parallellabs.com/tag/memory-visibility/" class="tag-cloud-link tag-link-51 tag-link-position-15" style="font-size: 1em;">memory visibility</a>
<a href="http://www.parallellabs.com/tag/microarchitecture/" class="tag-cloud-link tag-link-64 tag-link-position-16" style="font-size: 1em;">Microarchitecture</a>
<a href="http://www.parallellabs.com/tag/open-source/" class="tag-cloud-link tag-link-63 tag-link-position-17" style="font-size: 1em;">Open Source</a>
<a href="http://www.parallellabs.com/tag/pthreads/" class="tag-cloud-link tag-link-18 tag-link-position-18" style="font-size: 1em;">Pthreads</a>
<a href="http://www.parallellabs.com/tag/queue/" class="tag-cloud-link tag-link-37 tag-link-position-19" style="font-size: 1em;">queue</a>
<a href="http://www.parallellabs.com/tag/social-network-analytics/" class="tag-cloud-link tag-link-61 tag-link-position-20" style="font-size: 1em;">Social Network Analytics</a>
<a href="http://www.parallellabs.com/tag/thesis/" class="tag-cloud-link tag-link-8 tag-link-position-21" style="font-size: 1em;">Thesis</a>
<a href="http://www.parallellabs.com/tag/volatile/" class="tag-cloud-link tag-link-47 tag-link-position-22" style="font-size: 1em;">volatile</a>
<a href="http://www.parallellabs.com/tag/x-rime/" class="tag-cloud-link tag-link-62 tag-link-position-23" style="font-size: 1em;">X-RIME</a>
<a href="http://www.parallellabs.com/tag/review/" class="tag-cloud-link tag-link-89 tag-link-position-24" style="font-size: 1em;">业界评论</a>
<a href="http://www.parallellabs.com/tag/binary-system/" class="tag-cloud-link tag-link-33 tag-link-position-25" style="font-size: 1em;">二进制</a>
<a href="http://www.parallellabs.com/tag/%e4%ba%92%e8%81%94%e7%bd%91/" class="tag-cloud-link tag-link-48 tag-link-position-26" style="font-size: 1em;">互联网</a>
<a href="http://www.parallellabs.com/tag/%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f/" class="tag-cloud-link tag-link-46 tag-link-position-27" style="font-size: 1em;">分布式系统</a>
<a href="http://www.parallellabs.com/tag/atomic-operation/" class="tag-cloud-link tag-link-31 tag-link-position-28" style="font-size: 1em;">原子操作</a>
<a href="http://www.parallellabs.com/tag/multicore/" class="tag-cloud-link tag-link-20 tag-link-position-29" style="font-size: 1em;">多核</a>
<a href="http://www.parallellabs.com/tag/concurrency-bug/" class="tag-cloud-link tag-link-40 tag-link-position-30" style="font-size: 1em;">多线程Bug</a>
<a href="http://www.parallellabs.com/tag/memory-model/" class="tag-cloud-link tag-link-27 tag-link-position-31" style="font-size: 1em;">多线程内存模型</a>
<a href="http://www.parallellabs.com/tag/multithreaded-programming/" class="tag-cloud-link tag-link-21 tag-link-position-32" style="font-size: 1em;">多线程编程</a>
<a href="http://www.parallellabs.com/tag/%e5%ae%9e%e4%b9%a0/" class="tag-cloud-link tag-link-57 tag-link-position-33" style="font-size: 1em;">实习</a>
<a href="http://www.parallellabs.com/tag/%e5%b9%b4%e7%bb%88%e6%80%bb%e7%bb%93/" class="tag-cloud-link tag-link-14 tag-link-position-34" style="font-size: 1em;">年终总结</a>
<a href="http://www.parallellabs.com/tag/%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90/" class="tag-cloud-link tag-link-16 tag-link-position-35" style="font-size: 1em;">性能分析</a>
<a href="http://www.parallellabs.com/tag/deadlock/" class="tag-cloud-link tag-link-38 tag-link-position-36" style="font-size: 1em;">死锁</a>
<a href="http://www.parallellabs.com/tag/sweden/" class="tag-cloud-link tag-link-32 tag-link-position-37" style="font-size: 1em;">瑞典</a>
<a href="http://www.parallellabs.com/tag/%e7%a4%be%e4%ba%a4%e7%bd%91%e7%bb%9c/" class="tag-cloud-link tag-link-60 tag-link-position-38" style="font-size: 1em;">社交网络</a>
<a href="http://www.parallellabs.com/tag/%e7%a7%bb%e5%8a%a8%e5%bc%80%e5%8f%91/" class="tag-cloud-link tag-link-50 tag-link-position-39" style="font-size: 1em;">移动开发</a>
<a href="http://www.parallellabs.com/tag/system-architecture/" class="tag-cloud-link tag-link-90 tag-link-position-40" style="font-size: 1em;">系统架构</a>
<a href="http://www.parallellabs.com/tag/synchronization/" class="tag-cloud-link tag-link-22 tag-link-position-41" style="font-size: 1em;">线程同步</a>
<a href="http://www.parallellabs.com/tag/thread-safe/" class="tag-cloud-link tag-link-30 tag-link-position-42" style="font-size: 1em;">线程安全</a>
<a href="http://www.parallellabs.com/tag/%e8%81%8c%e4%b8%9a%e7%94%9f%e6%b6%af/" class="tag-cloud-link tag-link-41 tag-link-position-43" style="font-size: 1em;">职业生涯</a>
<a href="http://www.parallellabs.com/tag/%e9%94%81%e7%ab%9e%e4%ba%89/" class="tag-cloud-link tag-link-58 tag-link-position-44" style="font-size: 1em;">锁竞争</a>
<a href="http://www.parallellabs.com/tag/%e9%9d%a2%e8%af%95/" class="tag-cloud-link tag-link-24 tag-link-position-45" style="font-size: 1em;">面试</a></div>
</section>	</aside><!-- .sidebar .widget-area -->

		</div><!-- .site-content -->

		<footer id="colophon" class="site-footer" role="contentinfo">
			
			
			<div class="site-info">
								<span class="site-title"><a href="http://www.parallellabs.com/" rel="home">Parallel Labs </a></span>
				<a href="https://cn.wordpress.org/">自豪地采用WordPress</a>
			</div><!-- .site-info -->
		</footer><!-- .site-footer -->
	</div><!-- .site-inner -->
</div><!-- .site -->

<script type='text/javascript' src='http://parallellabs.qiniudn.com/wp-content/themes/twentysixteen/js/skip-link-focus-fix.js?ver=20160816'></script>
<script type='text/javascript' src='http://parallellabs.qiniudn.com/wp-includes/js/comment-reply.min.js?ver=4.8'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var screenReaderText = {"expand":"\u5c55\u5f00\u5b50\u83dc\u5355","collapse":"\u6298\u53e0\u5b50\u83dc\u5355"};
/* ]]> */
</script>
<script type='text/javascript' src='http://parallellabs.qiniudn.com/wp-content/themes/twentysixteen/js/functions.js?ver=20160816'></script>
<script type='text/javascript' src='http://parallellabs.qiniudn.com/wp-includes/js/wp-embed.min.js?ver=4.8'></script>
<script type='text/javascript' src='http://parallellabs.qiniudn.com/wp-content/plugins/akismet/_inc/form.js?ver=3.3.3'></script>
</body>
</html>

<!-- Dynamic page generated in 0.732 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-07-16 10:35:33 -->

<!-- super cache -->