<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta name="GENERATOR"
 content="Mozilla/4.02 [en] (X11; U; SunOS 5.5.1 sun4u) [Netscape]">
  <title>Java(tm) Debug Wire Protocol</title>
<meta name="collection" content="reference">
</head>
<body text="#000000" bgcolor="#ffffff" link="#0000ff" vlink="#000077"
 alink="#ff0000">
&nbsp;
<table summary="layout" border="0" width="100%">
  <tbody>
    <tr>
      <td width="60"><img src="../../images/javalogo52x88.gif"
 alt="Java" border="0" width="52" height="88"></td>
      <td>
      <center>
      <h1>Java<sup><font size="-2">TM</font></sup> Debug Wire Protocol</h1>
      </center>
      </td>
      <td width="60" valign="top"><a href="index.html">JPDA</a></td>
    </tr>
  </tbody>
</table>
<!-- Body text begins here -->
<p></p>
<h4><a href="jdwp/jdwp-protocol.html">Protocol details</a></h4>
<h3>Overview</h3>
<p>
The Java<sup><font size="-2">TM</font></sup> Debug Wire Protocol (JDWP)
is the protocol used for communication between a debugger and the Java
virtual machine (VM) which it debugs (hereafter called the target VM).  
JDWP is optional; it might not be available in some implementations of
the Java(TM) 2 SDK.
The existence of JDWP can allow
the same debugger to work
</p>
<ul>
  <li>in a different process on the same computer, or
  </li>
  <li>on a remote computer, </li>
</ul>
<p>
The JDWP
differs from many protocol specifications in that it only details
format and layout, not transport. A JDWP implementation can be designed
to accept different transport mechanisms through a simple API. A
particular transport does not necessarily support each of the
debugger/target VM combinations listed above.
</p>
<p>The JDWP is designed to be simple enough for easy implementation,
yet it is flexible enough for future growth.
</p>
<p>Currently, the JDWP does not specify any mechanism for transport
rendezvous or any directory services. This may be changed in the
future, but it may be addressed in a separate document.
</p>
<p>JDWP is one layer within the Java Platform Debugger Architecture
(JPDA). This architecture also
contains the higher-level Java Debug Interface (JDI). The JDWP is
designed to facilitate efficient use by
the JDI; many of its abilities are tailored to that end.
The JDI is more appropriate than JDWP for many debugger tools,
particularly those written in the Java programming language. For more
information on the Java Platform Debugger Architecture, see the <a
 href="index.html">Java Platform Debugger Architecture documentation</a>
for this release and the
<a href="http://java.sun.com/products/jpda">Java Platform Debugger
Architecture website</a>. </p>
<h3>JDWP Start Up</h3>
<p> After the transport connection is established and before any
packets are sent, a handshake occurs between the two sides of the
connection:
</p>
<p> The handshake process has the following steps: </p>
<ul>
  <li>The debugger side sends 14 bytes to the VM side, consisting of
the 14 ASCII characters of the string "JDWP-Handshake".</li>
  <li>The VM side replies with the same 14 bytes: JDWP-Handshake</li>
</ul>
<h3>JDWP Packets</h3>
<p>
The JDWP is packet based and is not stateful. There are two basic
packet types: command packets and reply packets.
</p>
<p>Command packets may be sent by either the debugger or the target VM.
They are used by the debugger to request information from the target
VM, or to control program execution. Command packets are sent by the
target VM to notify the debugger of some event in the target VM such as
a breakpoint or exception. </p>
<p>A reply packet is sent only in response to a command packet and
always provides information success or failure of the command. Reply
packets may also carry data requested in the command (for example, the
value of a field or variable). Currently, events sent from the target
VM do not require a response packet from the debugger.
</p>
<p>The JDWP is asynchronous; multiple command packets may be sent
before the first reply packet is received.
</p>
<p>Command and reply packet headers are equal in size; this is to make
transports easier to implement and abstract. The layout of each packet
looks like this:
</p>
<dl>
  <dt>Command Packet</dt>
  <dd>
    <ul>
      <li>Header
        <ul>
          <li>length (4 bytes)
          </li>
          <li>id (4 bytes)
          </li>
          <li>flags (1 byte)
          </li>
          <li>command set (1 byte)
          </li>
          <li>command (1 byte)
          </li>
        </ul>
      </li>
      <li>data (Variable)
      </li>
    </ul>
  </dd>
  <dt>Reply Packet</dt>
  <dd>
    <ul>
      <li>Header
        <ul>
          <li>length (4 bytes)
          </li>
          <li>id (4 bytes)
          </li>
          <li>flags (1 byte)
          </li>
          <li>error code (2 bytes)
          </li>
        </ul>
      </li>
      <li>data (Variable)
      </li>
    </ul>
  </dd>
</dl>
<p>
All fields and data sent via JDWP should be in big-endian format. (See
the Java Virtual Machine Specification for the definition of
big-endian.)
The first three fields are identical in both packet types.
</p>
<h4>Command and Reply Packet Fields</h4>
<h5>Shared Header Fields</h5>
<dl>
  <dt>length
  </dt>
  <dd>The length field is the size, in bytes, of the entire packet,
including the length field. The header size is 11 bytes, so a packet
with no data would set this field to 11.
  </dd>
  <dt>id
  </dt>
  <dd>The id field is used to uniquely identify each packet
command/reply pair. A reply packet has the same id as the command
packet
to which it replies. This allows asynchronous commands and replies to
be matched. The id field must be unique among all outstanding commands
sent from one source. (Outstanding commands originating from the
debugger may use the same id as outstanding commands originating from
the target VM.)
Other than that, there are no requirements on the allocation of id's.
    <p>A simple monotonic counter should be adequate for most
implementations. It will allow 2^32
unique outstanding packets and is the simplest implementation
alternative.
    </p>
  </dd>
  <dt>flags
  </dt>
  <dd>Flags are used to alter how any command is queued and processed
and to
tag command packets that originate from the target VM.
There is currently one flag bits defined; future versions of the
protocol may define additional flags.
    <p></p>
    <dl compact="compact">
      <dt><code>0x80</code> </dt>
      <dd>Reply packet
      </dd>
    </dl>
    <p>
The reply bit, when set, indicates that this packet is a reply.
    </p>
  </dd>
</dl>
<h5>Command Packet Header Fields</h5>
<dl>
  <dt>command set
  </dt>
  <dd>This field is useful as a means for grouping
commands in a meaningful way. The Sun defined command
sets are used to group commands by the interfaces they support in the
JDI.
For example, all commands that support the JDI VirtualMachine interface
are grouped in a VirtualMachine command set.
    <p>The command set space is roughly divided as follows:
    </p>
    <p></p>
    <dl compact="compact">
      <dt><code>0 - 63</code> </dt>
      <dd>Sets of commands sent to the target VM
      </dd>
      <dt><code>64 - 127</code> </dt>
      <dd>Sets of commands sent to the debugger
      </dd>
      <dt><code>128 - 256</code> </dt>
      <dd>Vendor-defined commands and extensions.
      </dd>
    </dl>
  </dd>
  <dt>command
  </dt>
  <dd>This field identifies a particular command in a command set. This
field, together with the command set field, is used to indicate how the
command packet should be processed. More succinctly, they tell the
receiver what to do. Specific commands are presented later in this
document.
  </dd>
</dl>
<h5>Reply Packet Header Fields</h5>
<dl>
  <dt>error code
  </dt>
  <dd>This field is used to indicate if the command packet that is
being replied too was successfully processed. A value of zero indicates
success, a non-zero value indicates an error.
The error code returned may be specific to each
command set/command, but it is often mapped to a JVMDI error code.
  </dd>
</dl>
<h5>Data</h5>
<dl>
The data field is unique to each command set/command. It is also
different between command and reply packet pairs. For example, a
command packet that requests a field value will contain references to
the object and
field id's for the desired value in its data field. The reply packet's
data field will contain the value of the field.
</dl>
<h3>Detailed Command Information</h3>
<p>
In general, the data field of a command or reply packet is an
abstraction of a group of multiple fields that define the command or
reply data. Each subfield of a data field is encoded in big endian
(Java) format. The detailed composition of data fields for each command
and its reply are described in this section. </p>
<p>There is a small set of common data
types that are common to many of the different JDWP commands and
replies. They are described below.
</p>
<p>
<table summary="common data types" border="1">
  <thead>
  <th scope="col">Name
  </th>
  <th scope="col">Size
  </th>
  <th scope="col">Description
  </th>
  </thead><tbody>
    <tr>
      <td><code>byte</code> </td>
      <td>1 byte
      </td>
      <td>A byte value.
      </td>
    </tr>
    <tr>
      <td><code>boolean</code> </td>
      <td>1 byte
      </td>
      <td>A boolean value, encoded as 0 for false and non-zero for
true. </td>
    </tr>
    <tr>
      <td><code>int</code> </td>
      <td>4 bytes
      </td>
      <td>An four-byte integer value. The integer is signed unless
explicitly
stated to be unsigned.
      </td>
    </tr>
    <tr>
      <td><code>long</code> </td>
      <td>8 bytes
      </td>
      <td>An eight-byte integer value. The value is signed unless
explicitly
stated to be unsigned.
      </td>
    </tr>
    <tr>
      <td><code>objectID</code> </td>
      <td>Target VM-specific, up to 8 bytes (see below)
      </td>
      <td>Uniquely identifies an object in the target VM. A particular
object will be identified by exactly one objectID in JDWP commands and
replies throughout its lifetime (or until the objectID is explicitly
disposed). An ObjectID is not reused to identify a different object
unless it has been explicitly <a
 href="jdwp/jdwp-protocol.html#JDWP_VirtualMachine_Dispose">disposed</a>,
regardless of whether the referenced object has been
garbage collected. An objectID of 0 represents a null object.
      <p>Note that the existence of an object ID does not prevent the
garbage collection of the object. Any attempt to access a a garbage
collected object with its object ID will result in the INVALID_OBJECT
error code.
Garbage collection can be disabled with the <a
 href="jdwp/jdwp-protocol.html#JDWP_ObjectReference_DisableCollection">DisableCollection</a>
command, but it is not usually necessary to do so.
      </p>
      </td>
    </tr>
    <tr>
      <td><code>tagged-objectID</code>
      </td>
      <td>size of objectID plus one byte
      </td>
      <td>The first byte is a signature byte which is used to identify
the object's type. See <a href="jdwp/jdwp-protocol.html#JDWP_Tag">JDWP.Tag</a>
for the
possible values of this byte (note that only object tags, not primitive
tags, may be used). It is followed immediately by the objectID itself.
      </td>
    </tr>
    <tr>
      <td><code>threadID</code>
      </td>
      <td>same as objectID
      </td>
      <td>Uniquely identifies an object in the target VM
that is known to be a thread
      </td>
    </tr>
    <tr>
      <td><code>threadGroupID</code>
      </td>
      <td>same as objectID
      </td>
      <td>Uniquely identifies an object in the target VM
that is known to be a thread group
      </td>
    </tr>
    <tr>
      <td><code>stringID</code>
      </td>
      <td>same as objectID
      </td>
      <td>Uniquely identifies an object in the target VM
that is known to be a string object. Note: this is very different
from string, which is a value.
      </td>
    </tr>
    <tr>
      <td><code>classLoaderID</code>
      </td>
      <td>same as objectID
      </td>
      <td>Uniquely identifies an object in the target VM
that is known to be a class loader object
      </td>
    </tr>
    <tr>
      <td><code>classObjectID</code>
      </td>
      <td>same as objectID
      </td>
      <td>Uniquely identifies an object in the target VM
that is known to be a class object.
      </td>
    </tr>
    <tr>
      <td><code>arrayID</code>
      </td>
      <td>same as objectID
      </td>
      <td>Uniquely identifies an object in the target VM
that is known to be an array.
      </td>
    </tr>
    <tr>
      <td><code>referenceTypeID</code>
      </td>
      <td>same as objectID
      </td>
      <td>Uniquely identifies a reference type in the target VM. It
should not be assumed that for a particular class, the <code>classObjectID</code>
and the <code>referenceTypeID</code> are the same.
A particular
reference type will be identified by exactly one ID in JDWP commands
and replies throughout its lifetime A referenceTypeID is not reused to
identify a different reference type,
regardless of whether the referenced class has been
unloaded.
      </td>
    </tr>
    <tr>
      <td><code>classID</code>
      </td>
      <td>same as referenceTypeID
      </td>
      <td>Uniquely identifies a reference type in the target VM that is
known to be a class type.
      </td>
    </tr>
    <tr>
      <td><code>interfaceID</code>
      </td>
      <td>same as referenceTypeID
      </td>
      <td>Uniquely identifies a reference type in the target VM that is
known to be an interface type.
      </td>
    </tr>
    <tr>
      <td><code>arrayTypeID</code>
      </td>
      <td>same as referenceTypeID
      </td>
      <td>Uniquely identifies a reference type in the target VM that is
known to be an array type.
      </td>
    </tr>
    <tr>
      <td><code>methodID</code> </td>
      <td>Target VM-specific, up to 8 bytes (see below)
      </td>
      <td>Uniquely identifies a method in some class in the target VM.
The methodID must uniquely identify the method within its
class/interface or any of its subclasses/subinterfaces/implementors. A
methodID is not
necessarily unique on its own; it is always paired with a
referenceTypeID
to uniquely identify one method. The referenceTypeID can identify
either
the declaring type of the method or a subtype.
      </td>
    </tr>
    <tr>
      <td><code>fieldID</code> </td>
      <td>Target VM-specific, up to 8 bytes (see below)
      </td>
      <td>Uniquely identifies a field in some class in the target VM.
The fieldID must uniquely identify the field within its
class/interface or any of its subclasses/subinterfaces/implementors.
A fieldID is not
necessarily unique on its own; it is always paired with a
referenceTypeID
to uniquely identify one field.
The referenceTypeID can identify either
the declaring type of the field or a subtype.
      </td>
    </tr>
    <tr>
      <td><code>frameID</code>
      </td>
      <td>Target VM-specific, up to 8 bytes (see below)
      </td>
      <td>Uniquely identifies a frame in the target VM. The
frameID must uniquely identify the frame within the
entire VM (not only within a given thread). The frameID need
only be valid during the time its thread is suspended.
      </td>
    </tr>
    <tr>
      <td><code>location</code> </td>
      <td>Target VM specific
      </td>
      <td>An executable location. The location is identified by
one byte <a href="jdwp/jdwp-protocol.html#JDWP_TypeTag">type tag</a>
followed by a a <code>classID</code> followed by a <code>methodID</code>
followed by an unsigned eight-byte index,
which identifies the location within
the method. Index values are restricted as follows:
      <ul>
        <li>The index of the start location for the method is less than
all other locations in the method. </li>
        <li>The index of the end location for the method is greater
than
all other locations in the method. </li>
        <li>If a line number table exists for a method, locations that
belong
to a particular line must fall between the line's location index
and the location index of the next line in the table.
        </li>
      </ul>
Index values within a method are monotonically increasing
from the first executable point in the method to the last. For many
implementations, each byte-code instruction in the method has its own
index, but this is not required.
      <p>The type tag is necessary to identify whether location's
classID
identifies a class or an interface. Almost all locations are within
classes, but it is possible to have executable code in the static
initializer of an interface.
      </p>
      </td>
    </tr>
    <tr>
      <td><code>string</code> </td>
      <td>Variable
      </td>
      <td>A UTF-8 encoded string, not zero terminated, preceded
by a four-byte integer length.
      </td>
    </tr>
    <tr>
      <td><code>value</code> </td>
      <td>Variable
      </td>
      <td>A value retrieved from the target VM. The first byte is a
signature byte which is used to identify the type. See <a
 href="jdwp/jdwp-protocol.html#JDWP_Tag">JDWP.Tag</a> for the
possible values of this byte. It is followed immediately by the value
itself.
This value can be
an objectID (see Get ID Sizes) or a primitive value (1 to 8 bytes).
More details about each value type can be found in the next table. </td>
    </tr>
    <tr>
      <td><code>untagged-value</code> </td>
      <td>Variable
      </td>
      <td>A <code>value</code> as described above without the
signature byte. This form is used when the signature information can be
determined from context.
      </td>
    </tr>
    <tr>
      <td><code>arrayregion</code> </td>
      <td>Variable
      </td>
      <td>A compact representation of values used with some array
operations.
The first byte is a signature byte which is used to identify the type.
See <a href="jdwp/jdwp-protocol.html#JDWP_Tag">JDWP.Tag</a> for the
possible values of this byte. Next is a four-byte integer indicating
the number of
values in the sequence. This is followed by the values themselves:
Primitive values are encoded as a sequence of <code>untagged-values</code>;
Object values are encoded
as a sequence of <code>values</code>. </td>
    </tr>
  </tbody>
</table>
</p>
<p>Object ids, reference type ids, field ids, method ids, and frame ids
may be sized differently in different target VM implementations.
Typically, their sizes correspond to size of the native identifiers
used for these items in JNI and JVMDI calls. The maximum size of any of
these types is 8 bytes. The "idSizes" command in the VirtualMachine
command set is used by the debugger to determine the size of each of
these types.
</p>
<p>If a debuggee receives a Command Packet with a non-implemented or
non-recognized command set or command then it returns a Reply Packet
with the error code field set to NOT_IMPLEMENTED (see
<a href="jdwp/jdwp-protocol.html#JDWP_Error">Error
Constants</a>).
</p>
<p></p>
<h2><a href="jdwp/jdwp-protocol.html">Protocol details</a></h2>
<p>
<!-- Body text ends here --><!-- ============================================================== -->
</p>
<hr size="3" noshade="noshade">
<table summary="layout" border="0" width="100%">
  <tbody>
    <tr valign="top">
      <td><font size="-2">Copyright &copy; 2004 <a
 href="http://www.oracle.com/">Sun
Microsystems, Inc.</a> All rights reserved.</font>&nbsp;
      <p><font size="-1">Please send comments to: <a
 href="mailto:java-debugger@sun.com">java-debugger@sun.com</a>&nbsp;</font></p>
      </td>
      <td align="right"><img src="../../images/sunlogo64x30.gif"
 alt="Sun" border="0" width="64" height="30"></td>
    </tr>
  </tbody>
</table>
&nbsp;
<!-- Start SiteCatalyst code   -->
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code_download.js"></script>
<script language="JavaScript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code.js"></script>
 
<!-- ********** DO NOT ALTER ANYTHING BELOW THIS LINE ! *********** -->
<!--  Below code will send the info to Omniture server -->
<script language="javascript">var s_code=s.t();if(s_code)document.write(s_code)</script>
 
<!-- End SiteCatalyst code -->
</body>
</html>
