

## arrays

> æ•°ç»„ï¼ˆarrayï¼‰æ˜¯ä¸€ç»„æ‹¥æœ‰ç›¸åŒç±»å‹ `T` çš„å¯¹è±¡çš„é›†åˆï¼Œåœ¨å†…å­˜ä¸­æ˜¯è¿ç»­å­˜å‚¨çš„ã€‚æ•°ç»„ä½¿ç”¨ä¸­æ‹¬å· `[]` æ¥åˆ›å»ºï¼Œä¸”å®ƒä»¬çš„å¤§å°åœ¨ç¼–è¯‘æ—¶ä¼šè¢«ç¡®å®šã€‚æ•°ç»„çš„ç±»å‹æ ‡è®°ä¸º `[T; length]`ï¼ˆè¯‘æ³¨ï¼š`T` ä¸ºå…ƒç´ ç±»å‹ï¼Œ`length` è¡¨ç¤ºæ•°ç»„å¤§å°ï¼‰ã€‚



ä¸€èˆ¬æ„ä¹‰ä¸Šçš„æ•°ç»„ï¼š
* é•¿åº¦ä¸å¯å˜
  `mut`è¡¨ç¤ºï¼Ÿ
* åŒä¸€ç±»å‹

å¦‚æœè¦è‡ªåŠ¨æ‰©å®¹çš„è¯ï¼š `vectors`

```rust
let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3
let mut b = [1, 2, 3];

let c: [i32; 0] = []; //[Type; NO of elements] -> [] /empty array
let d: [i32; 3] = [1, 2, 3];

let e = ["my value"; 3]; //["my value", "my value", "my value"];

println!("{:?}", a); //[1, 2, 3]
println!("{:#?}", a);
//  [
//      1,
//      2,
//      3
//  ]
```



* `&`å°±æˆäº†sliceæ˜¯ä¸æ˜¯æœ‰ç‚¹æ­¦æ–­ï¼Ÿ ğŸ˜‚

  è¿˜æœ‰æ²¡æœ‰ **æ•°ç»„çš„å¼•ç”¨** è¿™ä¸ªä¸œè¥¿/ç±»å‹ï¼Ÿ

  > è¯•äº†ä¸‹ï¼ŒåŸæ¥æ˜¯ä¸ªè¯­æ³•ç³–ï¼Œä¹Ÿå³å¯ä»¥æŠŠ æ•°ç»„å¼•ç”¨ ä½œä¸º slice ä¼ é€’ï¼Œä¼°è®¡åšäº†ä¸ªè£…ç®±
  >
  > ä½† **è¿˜æ˜¯æœ‰æ•°ç»„çš„å¼•ç”¨è¿™ä¸ªç±»å‹ï¼Œå¦‚ `&[i32; 5]`**

* `mut`åå³å¯ä¿®æ”¹
* indexè®¿é—®è¦ç”¨`[0]`è¿™ç§ï¼Œè€Œä¸èƒ½ç”¨tupleçš„`.0`è¿™ç§

* `let vv = ys[1 .. 4];` è¿™æ ·ä¼¼ä¹å¾—åˆ°çš„æ˜¯ä¸€ä¸ªä¸å®šé•¿æ•°ç»„ï¼Œè€Œå› ä¸ºç¼–è¯‘å™¨é•¿åº¦ä¸å¯çŸ¥ï¼Œæ‰€ä»¥ä¼šæŠ¥é”™

  > é‚£ä¸ºä»€ä¹ˆä¸å¹²è„†ä¸æ”¯æŒè¯¥è¯­æ³•å‘¢ï¼Ÿ



```rust
use std::mem;

// æ­¤å‡½æ•°å€Ÿç”¨ä¸€ä¸ª slice
fn analyze_slice(slice: &[i32]) {
    println!("first element of the slice: {}", slice[0]);
    println!("the slice has {} elements", slice.len());
}

// æ­¤å‡½æ•°å€Ÿç”¨ä¸€ä¸ª array
fn analyze_array(slice: &[i32; 5]) {
    println!("first element of the slice: {}", slice[0]);
    println!("the slice has {} elements", slice.len());
}

fn main() {
    // å®šé•¿æ•°ç»„ï¼ˆç±»å‹æ ‡è®°æ˜¯å¤šä½™çš„ï¼‰
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    analyze_array(&xs);  // array ref
  
    // æ‰€æœ‰å…ƒç´ å¯ä»¥åˆå§‹åŒ–æˆç›¸åŒçš„å€¼
    let ys: [i32; 500] = [0; 500];

    // ä¸‹æ ‡ä» 0 å¼€å§‹
    println!("first element of the array: {}", xs[0]);
    println!("second element of the array: {}", xs[1]);

    // `len` è¿”å›æ•°ç»„çš„å¤§å°
    println!("array size: {}", xs.len());

    // æ•°ç»„æ˜¯åœ¨æ ˆä¸­åˆ†é…çš„
    println!("array occupies {} bytes", mem::size_of_val(&xs));

    // æ•°ç»„å¯ä»¥è‡ªåŠ¨è¢«å€Ÿç”¨æˆä¸º slice
    println!("borrow the whole array as a slice");
    analyze_slice(&xs);  // array ref -> slice

    // slice å¯ä»¥æŒ‡å‘æ•°ç»„çš„ä¸€éƒ¨åˆ†
    println!("borrow a section of the array as a slice");
    analyze_slice(&ys[1 .. 4]);

    // è¶Šç•Œçš„ä¸‹æ ‡ä¼šå¼•å‘è‡´å‘½é”™è¯¯ï¼ˆpanicï¼‰
    println!("{}", xs[5]);
}

```







## slice

> åˆ‡ç‰‡ï¼ˆsliceï¼‰ç±»å‹å’Œæ•°ç»„ç±»ä¼¼ï¼Œä½†å…¶å¤§å°åœ¨ç¼–è¯‘æ—¶æ˜¯ä¸ç¡®å®šçš„ã€‚ç›¸åï¼Œåˆ‡ç‰‡æ˜¯ä¸€ä¸ªåŒå­—å¯¹è±¡ï¼ˆtwo-word objectï¼‰ï¼Œç¬¬ä¸€ä¸ªå­—æ˜¯ä¸€ä¸ªæŒ‡å‘æ•°æ®çš„æŒ‡é’ˆï¼Œç¬¬äºŒä¸ªå­—æ˜¯åˆ‡ç‰‡çš„é•¿åº¦ã€‚è¿™ä¸ª â€œå­—â€ çš„å®½åº¦å’Œ usize ç›¸åŒï¼Œç”±å¤„ç†å™¨æ¶æ„å†³å®šï¼Œæ¯”å¦‚åœ¨ x86-64 å¹³å°ä¸Šå°±æ˜¯ 64 ä½ã€‚slice å¯ä»¥ç”¨æ¥å€Ÿç”¨æ•°ç»„çš„ä¸€éƒ¨åˆ†ã€‚slice çš„ç±»å‹æ ‡è®°ä¸º `&[T]`ã€‚



* ä¸go sliceç±»ä¼¼
  * æœ¬èº«ä¸é™å®šé•¿åº¦
  * æŒ‡å‘å…¶ä»–æ•°æ®ç»“æ„ï¼ˆä¸»è¦æ˜¯æ•°ç»„ï¼Ÿï¼‰çš„å¼•ç”¨
  * æ”¯æŒåˆ‡ç‰‡æ“ä½œ
* ä¹Ÿæœ‰å·®åˆ«
  * åº”è¯¥ä¸èƒ½è‡ªåŠ¨æ‰©å®¹

```rust
let a: [i32; 4] = [1, 2, 3, 4];//Parent Array

let b: &[i32] = &a; //Slicing whole array
let c = &a[0..4]; // From 0th position to 4th(excluding)
let d = &a[..]; //Slicing whole array

let e = &a[1..3]; //[2, 3]
let f = &a[1..]; //[2, 3, 4]
let g = &a[..3]; //[1, 2, 3]
```





## tuples



> å…ƒç»„æ˜¯ä¸€ä¸ªå¯ä»¥åŒ…å«å„ç§ç±»å‹å€¼çš„ç»„åˆã€‚å…ƒç»„ä½¿ç”¨æ‹¬å· `()` æ¥æ„é€ ï¼ˆconstructï¼‰ï¼Œè€Œæ¯ä¸ªå…ƒç»„è‡ªèº«åˆæ˜¯ä¸€ä¸ªç±»å‹æ ‡è®°ä¸º `(T1, T2, ...)` çš„å€¼ï¼Œå…¶ä¸­ `T1`ã€`T2` æ˜¯æ¯ä¸ªå…ƒç´ çš„ç±»å‹ã€‚å‡½æ•°å¯ä»¥ä½¿ç”¨å…ƒç»„æ¥è¿”å›å¤šä¸ªå€¼ï¼Œå› ä¸ºå…ƒç»„å¯ä»¥æ‹¥æœ‰ä»»æ„å¤šä¸ªå€¼ã€‚

> å’Œpy tupleå¾ˆä¸ä¸€æ ·ï¼Œç±»ä¼¼ **å¿«æ·struct**ã€‚



* å›ºå®šé•¿åº¦ä¸å¯å˜
  
* `mut` åå¯ä¿®æ”¹å†…å®¹

* å…ƒç´ ç±»å‹å¯ä»¥ä¸åŒï¼Œä½†ç¡®å®šåä¸å¯å˜ï¼Œä¹Ÿå³åŒä¸€indexä½ç½®çš„ç±»å‹ä¸å¯å˜

  > ç­‰äºå…¶å®ä¹Ÿæœ‰ç¡®å®šç±»å‹ï¼ˆknown-size at compile timeï¼‰

```rust
let a = (1, 1.5, true, 'a', "Hello, world!");
// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = "Hello, world!"

let b: (i32, f64) = (1, 1.5);

let (c, d) = b; // c = 1, d = 1.5
let (e, _, _, _, f) = a; //e = 1, f = "Hello, world!", _ indicates not interested of that item

let g = (0,); //single-element tuple

let h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)

println!("{:?}", a); //(1, 1.5, true, 'a', "Hello, world!")
```





```rust
// å…ƒç»„å¯ä»¥å……å½“å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼
fn reverse(pair: (i32, bool)) -> (bool, i32) {
    // å¯ä»¥ä½¿ç”¨ `let` æŠŠä¸€ä¸ªå…ƒç»„çš„æˆå‘˜ç»‘å®šåˆ°ä¸€äº›å˜é‡
    let (integer, boolean) = pair;

    (boolean, integer)
}

// åœ¨ â€œåŠ¨æ‰‹è¯•ä¸€è¯•â€ çš„ç»ƒä¹ ä¸­è¦ç”¨åˆ°ä¸‹é¢è¿™ä¸ªç»“æ„ä½“ã€‚
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // åŒ…å«å„ç§ä¸åŒç±»å‹çš„å…ƒç»„
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // é€šè¿‡å…ƒç»„çš„ä¸‹æ ‡æ¥è®¿é—®å…·ä½“çš„å€¼
    println!("long tuple first value: {}", long_tuple.0);
    println!("long tuple second value: {}", long_tuple.1);

    // å…ƒç»„ä¹Ÿå¯ä»¥å……å½“å…ƒç»„çš„å…ƒç´ 
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // å…ƒç»„å¯ä»¥æ‰“å°
    println!("tuple of tuples: {:?}", tuple_of_tuples);

    // ä½†å¾ˆé•¿çš„å…ƒç»„æ— æ³•æ‰“å°
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!("too long tuple: {:?}", too_long_tuple);
    // è¯•ä¸€è¯• ^ å–æ¶ˆä¸Šé¢ä¸¤è¡Œçš„æ³¨é‡Šï¼Œé˜…è¯»ç¼–è¯‘å™¨ç»™å‡ºçš„é”™è¯¯ä¿¡æ¯ã€‚

    let pair = (1, true);
    println!("pair is {:?}", pair);

    println!("the reversed pair is {:?}", reverse(pair));

    // åˆ›å»ºå•å…ƒç´ å…ƒç»„éœ€è¦ä¸€ä¸ªé¢å¤–çš„é€—å·ï¼Œè¿™æ˜¯ä¸ºäº†å’Œè¢«æ‹¬å·åŒ…å«çš„å­—é¢é‡ä½œåŒºåˆ†ã€‚
    println!("one element tuple: {:?}", (5u32,));
    println!("just an integer: {:?}", (5u32));

    // å…ƒç»„å¯ä»¥è¢«è§£æ„ï¼ˆdeconstructï¼‰ï¼Œä»è€Œå°†å€¼ç»‘å®šç»™å˜é‡
    let tuple = (1, "hello", 4.5, true);

    let (a, b, c, d) = tuple;
    println!("{:?}, {:?}, {:?}, {:?}", a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!("{:?}", matrix)

}

```







