

# RAII



## ææ„ï¼š Drop

Rust ä¸­çš„ææ„å‡½æ•°æ¦‚å¿µæ˜¯é€šè¿‡ [`Drop`](https://rustwiki.org/zh-CN/std/ops/trait.Drop.html) trait æä¾›çš„ã€‚å½“èµ„æºç¦»å¼€ä½œç”¨åŸŸï¼Œå°±è°ƒç”¨ææ„å‡½æ•°ã€‚ä½ æ— éœ€ä¸ºæ¯ç§ç±»å‹éƒ½å®ç° [`Drop`](https://rustwiki.org/zh-CN/std/ops/trait.Drop.html) traitï¼Œåªè¦ä¸ºé‚£äº›éœ€è¦è‡ªå·±çš„ææ„å‡½æ•°é€»è¾‘çš„ç±»å‹å®ç°å°±å¯ä»¥äº†ã€‚



# ownership

å› ä¸ºå˜é‡è¦è´Ÿè´£é‡Šæ”¾å®ƒä»¬æ‹¥æœ‰çš„èµ„æºï¼Œæ‰€ä»¥**èµ„æºåªèƒ½æ‹¥æœ‰ä¸€ä¸ªæ‰€æœ‰è€…**ã€‚è¿™ä¹Ÿé˜²æ­¢äº†èµ„æºçš„é‡å¤é‡Šæ”¾ã€‚æ³¨æ„å¹¶éæ‰€æœ‰å˜é‡éƒ½æ‹¥æœ‰èµ„æºï¼ˆä¾‹å¦‚[å¼•ç”¨](http://localhost:3000/flow_control/match/destructuring/destructure_pointers.html)ï¼‰ã€‚

åœ¨è¿›è¡Œèµ‹å€¼ï¼ˆ`let x = y`ï¼‰æˆ–é€šè¿‡å€¼æ¥ä¼ é€’å‡½æ•°å‚æ•°ï¼ˆ`foo(x)`ï¼‰çš„æ—¶å€™ï¼Œèµ„æºçš„**æ‰€æœ‰æƒ**ï¼ˆownershipï¼‰ä¼šå‘ç”Ÿè½¬ç§»ã€‚æŒ‰ç…§ Rust çš„è¯´æ³•ï¼Œè¿™è¢«ç§°ä¸ºèµ„æºçš„**ç§»åŠ¨**ï¼ˆmoveï¼‰ã€‚

åœ¨ç§»åŠ¨èµ„æºä¹‹åï¼ŒåŸæ¥çš„æ‰€æœ‰è€…ä¸èƒ½å†è¢«ä½¿ç”¨ï¼Œè¿™å¯é¿å…æ‚¬æŒ‚æŒ‡é’ˆï¼ˆdangling pointerï¼‰çš„äº§ç”Ÿã€‚



```rust
// æ­¤å‡½æ•°å–å¾—å †åˆ†é…çš„å†…å­˜çš„æ‰€æœ‰æƒ
fn destroy_box(c: Box<i32>) {
    println!("Destroying a box that contains {}", c);

    // `c` è¢«é”€æ¯ä¸”å†…å­˜å¾—åˆ°é‡Šæ”¾
}

fn main() {
    // æ ˆåˆ†é…çš„æ•´å‹
    let x = 5u32;

    // å°† `x` *å¤åˆ¶*åˆ° `y`â€”â€”ä¸å­˜åœ¨èµ„æºç§»åŠ¨
    let y = x;

    // ä¸¤ä¸ªå€¼å„è‡ªéƒ½å¯ä»¥ä½¿ç”¨
    println!("x is {}, and y is {}", x, y);

    // `a` æ˜¯ä¸€ä¸ªæŒ‡å‘å †åˆ†é…çš„æ•´æ•°çš„æŒ‡é’ˆ
    let a = Box::new(5i32);

    println!("a contains: {}", a);
    // y: è¿™é‡Œå®åšäº†ä¸€äº›ç‰¹åˆ«çš„äº‹æƒ…ä½¿å¾—å®é™…åªåšäº†refå§ï¼Œå¦åˆ™è¿™é‡Œä¹Ÿmoveäº†

    // *ç§»åŠ¨* `a` åˆ° `b`
    let b = a;
    // æŠŠ `a` çš„æŒ‡é’ˆåœ°å€ï¼ˆè€Œéæ•°æ®ï¼‰å¤åˆ¶åˆ° `b`ã€‚ç°åœ¨ä¸¤è€…éƒ½æŒ‡å‘
    // åŒä¸€ä¸ªå †åˆ†é…çš„æ•°æ®ï¼Œä½†æ˜¯ç°åœ¨æ˜¯ `b` æ‹¥æœ‰å®ƒã€‚

    // æŠ¥é”™ï¼`a` ä¸èƒ½è®¿é—®æ•°æ®ï¼Œå› ä¸ºå®ƒä¸å†æ‹¥æœ‰é‚£éƒ¨åˆ†å †ä¸Šçš„å†…å­˜ã€‚
    //println!("a contains: {}", a);
    // è¯•ä¸€è¯• ^ å»æ‰æ­¤è¡Œæ³¨é‡Š

    // æ­¤å‡½æ•°ä» `b` ä¸­å–å¾—å †åˆ†é…çš„å†…å­˜çš„æ‰€æœ‰æƒ
    destroy_box(b);

    // æ­¤æ—¶å †å†…å­˜å·²ç»è¢«é‡Šæ”¾ï¼Œè¿™ä¸ªæ“ä½œä¼šå¯¼è‡´è§£å¼•ç”¨å·²é‡Šæ”¾çš„å†…å­˜ï¼Œè€Œè¿™æ˜¯ç¼–è¯‘å™¨ç¦æ­¢çš„ã€‚
    // æŠ¥é”™ï¼å’Œå‰é¢å‡ºé”™çš„åŸå› ä¸€æ ·ã€‚
    //println!("b contains: {}", b);
    // è¯•ä¸€è¯• ^ å»æ‰æ­¤è¡Œæ³¨é‡Š
}

```





## move



### moveæ—¶å¯èƒ½æ”¹å˜å¯å˜æ€§



å½“æ‰€æœ‰æƒè½¬ç§»æ—¶ï¼Œæ•°æ®çš„å¯å˜æ€§å¯èƒ½å‘ç”Ÿæ”¹å˜ã€‚

```rust
fn main() {
    let immutable_box = Box::new(5u32);

    println!("immutable_box contains {}", immutable_box);

    // å¯å˜æ€§é”™è¯¯
    //*immutable_box = 4;

    // *ç§»åŠ¨* boxï¼Œæ”¹å˜æ‰€æœ‰æƒï¼ˆå’Œå¯å˜æ€§ï¼‰
    let mut mutable_box = immutable_box;

    println!("mutable_box contains {}", mutable_box);

    // ä¿®æ”¹ box çš„å†…å®¹
    *mutable_box = 4;

    println!("mutable_box now contains {}", mutable_box);
}

```



### éƒ¨åˆ†move

åœ¨å•ä¸ªå˜é‡çš„[è§£æ„](http://localhost:3000/flow_control/match/destructuring.html)å†…ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ `by-move` å’Œ `by-reference` æ¨¡å¼ç»‘å®šã€‚è¿™æ ·åšå°†å¯¼è‡´å˜é‡çš„**éƒ¨åˆ†ç§»åŠ¨**ï¼ˆpartial moveï¼‰ï¼Œè¿™æ„å‘³ç€å˜é‡çš„æŸäº›éƒ¨åˆ†å°†è¢«ç§»åŠ¨ï¼Œè€Œå…¶ä»–éƒ¨åˆ†å°†ä¿ç•™ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåé¢ä¸èƒ½æ•´ä½“ä½¿ç”¨çˆ¶çº§å˜é‡ï¼Œä½†æ˜¯ä»ç„¶å¯ä»¥ä½¿ç”¨åªå¼•ç”¨ï¼ˆè€Œä¸ç§»åŠ¨ï¼‰çš„éƒ¨åˆ†ã€‚

```rust
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: u8,
    }

    let person = Person {
        name: String::from("Alice"),
        age: 20,
    };

    // `name` ä» person ä¸­ç§»èµ°ï¼Œä½† `age` åªæ˜¯å¼•ç”¨
    let Person { name, ref age } = person;

    println!("The person's age is {}", age);

    println!("The person's name is {}", name);

    // æŠ¥é”™ï¼éƒ¨åˆ†ç§»åŠ¨å€¼çš„å€Ÿç”¨ï¼š`person` éƒ¨åˆ†å€Ÿç”¨äº§ç”Ÿ
    //println!("The person struct is {:?}", person);

    // `person` ä¸èƒ½ä½¿ç”¨ï¼Œä½† `person.age` å› ä¸ºæ²¡æœ‰è¢«ç§»åŠ¨è€Œå¯ä»¥ç»§ç»­ä½¿ç”¨
    println!("The person's age from person struct is {}", person.age);
}
```





## misc

### èµ‹å€¼ã€ä¼ å‚ æ“ä½œçš„è¯­ä¹‰ï¼š move/copy

> è¿™é‡ŒæŒ‡çš„æ˜¯ç›´æ¥å¯¹å€¼çš„æ“ä½œï¼Œæ²¡æœ‰è¿›è¡Œå¼•ç”¨

* å¯¹äºcopyç±»å‹

  * ç›¸å…³çš„èµ„æºä¼šåšcopyå†ã€‚ã€‚ã€‚

    > ä½†æ€ä¹ˆâ€œçœ‹å‡ºâ€æ˜¯ä»€ä¹ˆå±‚é¢çš„copyï¼Ÿ æµ…æ‹·è´è¿˜æ˜¯æ·±æ‹·è´ï¼Ÿ ç­‰ç­‰

  * "copy" ååŸæ¥çš„bindingçš„çŠ¶æ€ä¸º "copied"

  * ä¸»è¦æ˜¯åŸºæœ¬ç±»å‹

* å¯¹äºmoveç±»å‹

  * ç›¸å…³çš„èµ„æºä¼šmoveåˆ°æ–°çš„bindingï¼Œè€ŒåŸæ¥çš„bindingä¸èƒ½å†è®¿é—®
  * "move" ååŸæ¥çš„bindingçš„çŠ¶æ€ä¸º "moved"
  * éåŸºæœ¬ç±»å‹

ä»¥ä¸Šçš„è¯­ä¹‰æ“ä½œï¼Œæ˜¯åŸºäºï¼ˆç±»å‹ï¼‰å®ç°çš„traitæ¥ç¡®å®šçš„ã€‚ `move`æ˜¯é»˜è®¤è¯­ä¹‰ï¼Œé™¤éç±»å‹å®ç°äº† `core::marker::Copy` è¿™ä¸ªtraitï¼ˆæ‰ä¼šæœ‰`copy`è¯­ä¹‰ï¼‰ã€‚

# borrow

å¤šæ•°æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æ›´å¸Œæœ›èƒ½è®¿é—®æ•°æ®ï¼ŒåŒæ—¶ä¸å–å¾—å…¶æ‰€æœ‰æƒã€‚ä¸ºå®ç°è¿™ç‚¹ï¼ŒRust ä½¿ç”¨äº†**å€Ÿç”¨**ï¼ˆborrowingï¼‰æœºåˆ¶ã€‚å¯¹è±¡å¯ä»¥é€šè¿‡å¼•ç”¨ï¼ˆ`&T`ï¼‰æ¥ä¼ é€’ï¼Œä»è€Œå–ä»£é€šè¿‡å€¼ï¼ˆ`T`ï¼‰æ¥ä¼ é€’ã€‚

ç¼–è¯‘å™¨ï¼ˆé€šè¿‡å€Ÿç”¨æ£€æŸ¥ï¼‰é™æ€åœ°ä¿è¯äº†å¼•ç”¨**æ€»æ˜¯**æŒ‡å‘æœ‰æ•ˆçš„å¯¹è±¡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“å­˜åœ¨å¼•ç”¨æŒ‡å‘ä¸€ä¸ªå¯¹è±¡æ—¶ï¼Œè¯¥å¯¹è±¡ä¸èƒ½è¢«é”€æ¯ã€‚



```rust
// æ­¤å‡½æ•°å–å¾—ä¸€ä¸ª box çš„æ‰€æœ‰æƒå¹¶é”€æ¯å®ƒ
fn eat_box_i32(boxed_i32: Box<i32>) {
    println!("Destroying box that contains {}", boxed_i32);
}

// æ­¤å‡½æ•°å€Ÿç”¨äº†ä¸€ä¸ª i32 ç±»å‹
fn borrow_i32(borrowed_i32: &i32) {
    println!("This int is: {}", borrowed_i32);
}

fn main() {
    // åˆ›å»ºä¸€ä¸ªè£…ç®±çš„ i32 ç±»å‹ï¼Œä»¥åŠä¸€ä¸ªå­˜åœ¨æ ˆä¸­çš„ i32 ç±»å‹ã€‚
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // å€Ÿç”¨äº† box çš„å†…å®¹ï¼Œä½†æ²¡æœ‰å–å¾—æ‰€æœ‰æƒï¼Œæ‰€ä»¥ box çš„å†…å®¹ä¹‹åå¯ä»¥å†æ¬¡å€Ÿç”¨ã€‚
    // è¯‘æ³¨ï¼šè¯·æ³¨æ„å‡½æ•°è‡ªèº«å°±æ˜¯ä¸€ä¸ªä½œç”¨åŸŸï¼Œå› æ­¤ä¸‹é¢ä¸¤ä¸ªå‡½æ•°è¿è¡Œå®Œæˆä»¥åï¼Œ
    // åœ¨å‡½æ•°ä¸­ä¸´æ—¶åˆ›å»ºçš„å¼•ç”¨ä¹Ÿå°±ä¸å¤å­˜åœ¨äº†ã€‚
    borrow_i32(&boxed_i32);  // y: ç«Ÿç„¶å¯ä»¥ &Box<T> ç›´æ¥å½“ &T ç”¨ã€‚ è™½ç„¶å®ç°ä¸Šå¦‚æ­¤ï¼Œä½†ç±»å‹ä¸Šç«Ÿç„¶ä¹Ÿã€‚ã€‚ æ˜¯å› ä¸ºå®ç°äº† `AsRef<T>`å—ï¼Ÿ as_ref æ–¹æ³•
    borrow_i32(&stacked_i32);

    {
        // å–å¾—ä¸€ä¸ªå¯¹ box ä¸­æ•°æ®çš„å¼•ç”¨
        let _ref_to_i32: &i32 = &boxed_i32;

        // æŠ¥é”™ï¼
        // å½“ `boxed_i32` é‡Œé¢çš„å€¼ä¹‹ååœ¨ä½œç”¨åŸŸä¸­è¢«å€Ÿç”¨æ—¶ï¼Œä¸èƒ½å°†å…¶é”€æ¯ã€‚
        eat_box_i32(boxed_i32);
        // æ”¹æ­£ ^ æ³¨é‡Šæ‰æ­¤è¡Œ

        // åœ¨ `_ref_to_i32` é‡Œé¢çš„å€¼è¢«é”€æ¯åï¼Œå°è¯•å€Ÿç”¨ `_ref_to_i32`
        //ï¼ˆè¯‘æ³¨ï¼šå¦‚æœæ­¤å¤„ä¸å€Ÿç”¨ï¼Œåˆ™åœ¨ä¸Šä¸€è¡Œçš„ä»£ç ä¸­ï¼Œeat_box_i32(boxed_i32)å¯ä»¥å°† `boxed_i32` é”€æ¯ã€‚ï¼‰
        borrow_i32(_ref_to_i32);
        // `_ref_to_i32` ç¦»å¼€ä½œç”¨åŸŸä¸”ä¸å†è¢«å€Ÿç”¨ã€‚
    }

    // `boxed_i32` ç°åœ¨å¯ä»¥å°†æ‰€æœ‰æƒäº¤ç»™ `eat_i32` å¹¶è¢«é”€æ¯ã€‚
    //ï¼ˆè¯‘æ³¨ï¼šèƒ½å¤Ÿé”€æ¯æ˜¯å› ä¸ºå·²ç»ä¸å­˜åœ¨å¯¹ `boxed_i32` çš„å¼•ç”¨ï¼‰
    eat_box_i32(boxed_i32);
}

```







## borrowæ—¶å¯å˜ï¼š mut ref

å¯å˜æ•°æ®å¯ä»¥ä½¿ç”¨ `&mut T` è¿›è¡Œå¯å˜å€Ÿç”¨ã€‚è¿™å«åš**å¯å˜å¼•ç”¨**ï¼ˆmutable referenceï¼‰ï¼Œå®ƒä½¿å€Ÿç”¨è€…å¯ä»¥è¯»/å†™æ•°æ®ã€‚ç›¸åï¼Œ`&T` é€šè¿‡ä¸å¯å˜å¼•ç”¨ï¼ˆimmutable referenceï¼‰æ¥å€Ÿç”¨æ•°æ®ï¼Œå€Ÿç”¨è€…å¯ä»¥è¯»æ•°æ®è€Œä¸èƒ½æ›´æ”¹æ•°æ®ï¼š



```rust
#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&'static str` æ˜¯ä¸€ä¸ªå¯¹åˆ†é…åœ¨åªè¯»å†…å­˜åŒºçš„å­—ç¬¦ä¸²çš„å¼•ç”¨
    author: &'static str,
    title: &'static str,
    year: u32,
}

// æ­¤å‡½æ•°æ¥å—ä¸€ä¸ªå¯¹ Book ç±»å‹çš„å¼•ç”¨
fn borrow_book(book: &Book) {
    println!("I immutably borrowed {} - {} edition", book.title, book.year);
}

// æ­¤å‡½æ•°æ¥å—ä¸€ä¸ªå¯¹å¯å˜çš„ Book ç±»å‹çš„å¼•ç”¨ï¼Œå®ƒæŠŠå¹´ä»½ `year` æ”¹ä¸º 2014 å¹´
fn new_edition(book: &mut Book) {
    book.year = 2014;
    println!("I mutably borrowed {} - {} edition", book.title, book.year);
}

fn main() {
    // åˆ›å»ºä¸€ä¸ªåä¸º `immutabook` çš„ä¸å¯å˜çš„ Book å®ä¾‹
    let immutabook = Book {
        // å­—ç¬¦ä¸²å­—é¢é‡æ‹¥æœ‰ `&'static str` ç±»å‹
        author: "Douglas Hofstadter",
        title: "GÃ¶del, Escher, Bach",
        year: 1979,
    };

    // åˆ›å»ºä¸€ä¸ª `immutabook` çš„å¯å˜æ‹·è´ï¼Œå‘½åä¸º `mutabook`
    let mut mutabook = immutabook;  // y: å®ç°äº†copyæ‰€ä»¥...

    // ä¸å¯å˜åœ°å€Ÿç”¨ä¸€ä¸ªä¸å¯å˜å¯¹è±¡
    borrow_book(&immutabook);

    // ä¸å¯å˜åœ°å€Ÿç”¨ä¸€ä¸ªå¯å˜å¯¹è±¡
    borrow_book(&mutabook);

    // å¯å˜åœ°å€Ÿç”¨ä¸€ä¸ªå¯å˜å¯¹è±¡
    new_edition(&mut mutabook);

    // æŠ¥é”™ï¼ä¸èƒ½å¯å˜åœ°å€Ÿç”¨ä¸€ä¸ªä¸å¯å˜å¯¹è±¡
    new_edition(&mut immutabook);
    // æ”¹æ­£ ^ æ³¨é‡Šæ‰æ­¤è¡Œ
}

```





## borrowæ—¶çš„â€œè¯»å†™äº’æ–¥â€



> åŸæ–‡å« åˆ«åä½¿ç”¨

æ•°æ®å¯ä»¥å¤šæ¬¡ä¸å¯å˜å€Ÿç”¨ï¼Œä½†æ˜¯åœ¨ä¸å¯å˜å€Ÿç”¨çš„åŒæ—¶ï¼ŒåŸå§‹æ•°æ®ä¸èƒ½ä½¿ç”¨å¯å˜å€Ÿç”¨ã€‚æˆ–è€…è¯´ï¼ŒåŒä¸€æ—¶é—´å†…åªå…è®¸**ä¸€æ¬¡**å¯å˜å€Ÿç”¨ã€‚ä»…å½“æœ€åä¸€æ¬¡ä½¿ç”¨å¯å˜å¼•ç”¨**ä¹‹å**ï¼ŒåŸå§‹æ•°æ®æ‰å¯ä»¥å†æ¬¡å€Ÿç”¨ã€‚

```rust
struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    let borrowed_point = &point;
    let another_borrow = &point;

    // æ•°æ®å¯ä»¥é€šè¿‡å¼•ç”¨æˆ–åŸå§‹ç±»å‹æ¥è®¿é—®
    println!("Point has coordinates: ({}, {}, {})",
                borrowed_point.x, another_borrow.y, point.z);
    
    // æŠ¥é”™ï¼`point` ä¸èƒ½ä»¥å¯å˜æ–¹å¼å€Ÿç”¨ï¼Œå› ä¸ºå½“å‰è¿˜æœ‰ä¸å¯å˜å€Ÿç”¨ã€‚
    // let mutable_borrow = &mut point;
    // TODO ^ è¯•ä¸€è¯•å»æ‰æ­¤è¡Œæ³¨é‡Š

    // è¢«å€Ÿç”¨çš„å€¼åœ¨è¿™é‡Œè¢«é‡æ–°ä½¿ç”¨
    println!("Point has coordinates: ({}, {}, {})",
                borrowed_point.x, another_borrow.y, point.z);

    // ä¸å¯å˜çš„å¼•ç”¨ä¸å†ç”¨äºå…¶ä½™çš„ä»£ç ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨å¯å˜çš„å¼•ç”¨é‡æ–°å€Ÿç”¨ã€‚
    let mutable_borrow = &mut point;

    // é€šè¿‡å¯å˜å¼•ç”¨æ¥ä¿®æ”¹æ•°æ®
    mutable_borrow.x = 5;
    mutable_borrow.y = 2;
    mutable_borrow.z = 1;

    // æŠ¥é”™ï¼ä¸èƒ½å†ä»¥ä¸å¯å˜æ–¹å¼æ¥å€Ÿç”¨ `point`ï¼Œå› ä¸ºå®ƒå½“å‰å·²ç»è¢«å¯å˜å€Ÿç”¨ã€‚
    // let y = &point.y;
    // TODO ^ è¯•ä¸€è¯•å»æ‰æ­¤è¡Œæ³¨é‡Š

    // æŠ¥é”™ï¼æ— æ³•æ‰“å°ï¼Œå› ä¸º `println!` ç”¨åˆ°äº†ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ã€‚
    // println!("Point Z coordinate is {}", point.z);
    // TODO ^ è¯•ä¸€è¯•å»æ‰æ­¤è¡Œæ³¨é‡Š

    // æ­£å¸¸è¿è¡Œï¼å¯å˜å¼•ç”¨èƒ½å¤Ÿä»¥ä¸å¯å˜ç±»å‹ä¼ å…¥ `println!`
    println!("Point has coordinates: ({}, {}, {})",
                mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

    // å¯å˜å¼•ç”¨ä¸å†ç”¨äºå…¶ä½™çš„ä»£ç ï¼Œå› æ­¤å¯ä»¥é‡æ–°å€Ÿç”¨
    let new_borrowed_point = &point;
    println!("Point now has coordinates: ({}, {}, {})",
             new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z);
}

```



## refå…³é”®å­—



åœ¨é€šè¿‡ `let` ç»‘å®šæ¥è¿›è¡Œæ¨¡å¼åŒ¹é…æˆ–è§£æ„æ—¶ï¼Œ`ref` å…³é”®å­—å¯ç”¨æ¥åˆ›å»ºç»“æ„ä½“/å…ƒç»„çš„å­—æ®µçš„å¼•ç”¨ã€‚ä¸‹é¢çš„ä¾‹å­å±•ç¤ºäº†å‡ ä¸ªå®ä¾‹ï¼Œå¯çœ‹åˆ° `ref` çš„ä½œç”¨ï¼š

```rust
#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // èµ‹å€¼è¯­å¥ä¸­å·¦è¾¹çš„ `ref` å…³é”®å­—ç­‰ä»·äºå³è¾¹çš„ `&` ç¬¦å·ã€‚
    let ref ref_c1 = c;
    let ref_c2 = &c;

    println!("ref_c1 equals ref_c2: {}", *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // åœ¨è§£æ„ä¸€ä¸ªç»“æ„ä½“æ—¶ `ref` åŒæ ·æœ‰æ•ˆã€‚
    let _copy_of_x = {
        // `ref_to_x` æ˜¯ä¸€ä¸ªæŒ‡å‘ `point` çš„ `x` å­—æ®µçš„å¼•ç”¨ã€‚
        let Point { x: ref ref_to_x, y: _ } = point;

        // è¿”å›ä¸€ä¸ª `point` çš„ `x` å­—æ®µçš„æ‹·è´ã€‚
        *ref_to_x
        // *&point.x
        // point.x
        // y: ä»¥ä¸Šçš†å¯
        // TODO y: å¦‚æœ x æ²¡å®ç° copy çš„è¯ï¼Œè§£å¼•ç”¨ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
    };

    // `point` çš„å¯å˜æ‹·è´
    let mut mutable_point = point;

    {
        // `ref` å¯ä»¥ä¸ `mut` ç»“åˆä»¥åˆ›å»ºå¯å˜å¼•ç”¨ã€‚
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // é€šè¿‡å¯å˜å¼•ç”¨æ¥æ”¹å˜ `mutable_point` çš„å­—æ®µ `y`ã€‚
        *mut_ref_to_y = 1;
    }

    println!("point is ({}, {})", point.x, point.y);
    println!("mutable_point is ({}, {})", mutable_point.x, mutable_point.y);

    // åŒ…å«ä¸€ä¸ªæŒ‡é’ˆçš„å¯å˜å…ƒç»„
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // è§£æ„ `mutable_tuple` æ¥æ”¹å˜ `last` çš„å€¼ã€‚
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!("tuple is {:?}", mutable_tuple);
}

```





## misc

### å–å¼•ç”¨çš„è¯­ä¹‰ï¼š borrow

* `&`
* `&mut`

ç†è§£ï¼š

* çœ‹èµ·æ¥åƒï¼ˆå…¶ä»–è¯­è¨€çš„ï¼‰å–æŒ‡é’ˆ

  > ä»raw pointerçš„è¯­æ³•`let raw = &x as *const i32;`æ¥çœ‹å®ç°ä¼°è®¡ä¹Ÿæ˜¯æŒ‡é’ˆ

* borrowè¯­ä¹‰ï¼š To receive something with the promise of returning it.
  ä¸¤ç§borrow

  * shared (`&T`)
    A piece of data can be borrowed by a single or multiple users, but data should not be altered.

    > å…¶å®å‘½åæŒºå¥‡æ€ªï¼Œä¸ºå•¥ä¸å«readonlyã€immutableï¼Ÿ åªæ˜¯å› ä¸ºè¯»å†™é”æ¦‚å¿µé‡Œè¯»æ˜¯å¯å¤šé‡/å…±äº«çš„ï¼Ÿ

  * mutable (`&mut T`)
    A piece of data can be borrowed and altered by a single user, but the data should not be accessible for any other users at that time.

  è§„åˆ™ï¼š å¯ä»¥å‚è€ƒè¯»å†™é”

  * å¯è¯»å¯å†™ä¸èƒ½åŒæ—¶ï¼ˆéœ€å¾…å¦ä¸€ç§ç”Ÿå­˜æœŸç»“æŸ
  * borrowå¯ä»¥å¯¹move/copyç±»å‹
  * ç”Ÿå­˜æœŸ æ¦‚å¿µ

# lifetime

**ç”Ÿå‘½å‘¨æœŸ**ï¼ˆlifetimeï¼‰æ˜¯è¿™æ ·ä¸€ç§æ¦‚å¿µï¼Œç¼–è¯‘å™¨ï¼ˆä¸­çš„å€Ÿç”¨æ£€æŸ¥å™¨ï¼‰ç”¨å®ƒæ¥ä¿è¯æ‰€æœ‰çš„å€Ÿç”¨éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚ç¡®åˆ‡åœ°è¯´ï¼Œä¸€ä¸ªå˜é‡çš„ç”Ÿå‘½å‘¨æœŸåœ¨å®ƒåˆ›å»ºçš„æ—¶å€™å¼€å§‹ï¼Œåœ¨å®ƒé”€æ¯çš„æ—¶å€™ç»“æŸã€‚è™½ç„¶ç”Ÿå‘½å‘¨æœŸå’Œä½œç”¨åŸŸç»å¸¸è¢«ä¸€èµ·æåˆ°ï¼Œä½†å®ƒä»¬å¹¶ä¸ç›¸åŒã€‚

ä¾‹å¦‚è€ƒè™‘è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬é€šè¿‡ `&` æ¥å€Ÿç”¨ä¸€ä¸ªå˜é‡ã€‚è¯¥**å€Ÿç”¨æ‹¥æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œæ­¤ç”Ÿå‘½å‘¨æœŸç”±å®ƒå£°æ˜çš„ä½ç½®å†³å®š**ã€‚äºæ˜¯ï¼Œåªè¦è¯¥å€Ÿç”¨åœ¨å‡ºå€Ÿè€…ï¼ˆlenderï¼‰è¢«é”€æ¯å‰ç»“æŸï¼Œå€Ÿç”¨å°±æ˜¯æœ‰æ•ˆçš„ã€‚ç„¶è€Œï¼Œ**å€Ÿç”¨çš„ä½œç”¨åŸŸåˆ™æ˜¯ç”±ä½¿ç”¨å¼•ç”¨çš„ä½ç½®å†³å®šçš„**ã€‚

åœ¨ä¸‹é¢çš„ä¾‹å­å’Œæœ¬ç« èŠ‚å‰©ä¸‹çš„å†…å®¹é‡Œï¼Œæˆ‘ä»¬å°†çœ‹åˆ°ç”Ÿå‘½å‘¨æœŸå’Œä½œç”¨åŸŸçš„è”ç³»ä¸åŒºåˆ«ã€‚

> è¯‘æ³¨ï¼šå¦‚æœä»£ç ä¸­çš„ç”Ÿå‘½å‘¨æœŸç¤ºæ„å›¾ä¹±æ‰äº†ï¼Œè¯·æŠŠå®ƒå¤åˆ¶åˆ°ä»»ä½•ç¼–è¾‘å™¨ä¸­ï¼Œç”¨ç­‰å®½å­—ä½“æŸ¥çœ‹ã€‚ä¸ºé¿å…ä¸­æ–‡çš„æ˜¾ç¤ºé—®é¢˜ï¼Œä¸‹é¢ä¸€äº›æ³¨é‡Šæ²¡æœ‰ç¿»è¯‘ã€‚

```
// ä¸‹é¢ä½¿ç”¨è¿çº¿æ¥æ ‡æ³¨å„ä¸ªå˜é‡çš„åˆ›å»ºå’Œé”€æ¯ï¼Œä»è€Œæ˜¾ç¤ºå‡ºç”Ÿå‘½å‘¨æœŸã€‚
// `i` çš„ç”Ÿå‘½å‘¨æœŸæœ€é•¿ï¼Œå› ä¸ºå®ƒçš„ä½œç”¨åŸŸå®Œå…¨è¦†ç›–äº† `borrow1` å’Œ
// `borrow2` çš„ã€‚`borrow1` å’Œ `borrow2` çš„å‘¨æœŸæ²¡æœ‰å…³è”ï¼Œ
// å› ä¸ºå®ƒä»¬å„ä¸ç›¸äº¤ã€‚
fn main() {
    let i = 3; // Lifetime for `i` starts. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    //                                                     â”‚
    { //                                                   â”‚
        let borrow1 = &i; // `borrow1` lifetime starts. â”€â”€â”â”‚
        //                                                â”‚â”‚
        println!("borrow1: {}", borrow1); //              â”‚â”‚
    } // `borrow1 ends. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
    //                                                     â”‚
    //                                                     â”‚
    { //                                                   â”‚
        let borrow2 = &i; // `borrow2` lifetime starts. â”€â”€â”â”‚
        //                                                â”‚â”‚
        println!("borrow2: {}", borrow2); //              â”‚â”‚
    } // `borrow2` ends. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
    //                                                     â”‚
}   // Lifetime ends. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

æ³¨æ„åˆ°è¿™é‡Œæ²¡æœ‰ç”¨åˆ°åç§°æˆ–ç±»å‹æ¥æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼Œè¿™é™åˆ¶äº†ç”Ÿå‘½å‘¨æœŸçš„ç”¨æ³•ï¼Œåœ¨åé¢æˆ‘ä»¬å°†ä¼šçœ‹åˆ°ç”Ÿå‘½å‘¨æœŸæ›´å¼ºå¤§çš„åŠŸèƒ½ã€‚





## æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ



```rust
// `print_refs` æ¥å—ä¸¤ä¸ª `i32` çš„å¼•ç”¨ï¼Œå®ƒä»¬æœ‰ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸ `'a` å’Œ `'b`ã€‚
// è¿™ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸéƒ½å¿…é¡»è‡³å°‘è¦å’Œ `print_refs` å‡½æ•°ä¸€æ ·é•¿ã€‚
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}

// ä¸å¸¦å‚æ•°çš„å‡½æ•°ï¼Œä¸è¿‡æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•° `'a`ã€‚
fn failed_borrow<'a>() {
    let _x = 12;

    // æŠ¥é”™ï¼š`_x` çš„ç”Ÿå‘½å‘¨æœŸä¸å¤Ÿé•¿
    //let y: &'a i32 = &_x;
    // åœ¨å‡½æ•°å†…éƒ¨ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸ `'a` ä½œä¸ºæ˜¾å¼ç±»å‹æ ‡æ³¨å°†å¯¼è‡´å¤±è´¥ï¼Œå› ä¸º `&_x` çš„
    // ç”Ÿå‘½å‘¨æœŸæ¯” `y` çš„çŸ­ã€‚çŸ­ç”Ÿå‘½å‘¨æœŸä¸èƒ½å¼ºåˆ¶è½¬æ¢æˆé•¿ç”Ÿå‘½å‘¨æœŸã€‚
}

fn main() {
    // åˆ›å»ºå˜é‡ï¼Œç¨åç”¨äºå€Ÿç”¨ã€‚
    let (four, nine) = (4, 9);

    // ä¸¤ä¸ªå˜é‡çš„å€Ÿç”¨ï¼ˆ`&`ï¼‰éƒ½ä¼ è¿›å‡½æ•°ã€‚
    print_refs(&four, &nine);
    // ä»»ä½•è¢«å€Ÿç”¨çš„è¾“å…¥é‡éƒ½å¿…é¡»æ¯”å€Ÿç”¨è€…ç”Ÿå­˜å¾—æ›´é•¿ã€‚
    // ä¹Ÿå°±æ˜¯è¯´ï¼Œ`four` å’Œ `nine` çš„ç”Ÿå‘½å‘¨æœŸéƒ½å¿…é¡»æ¯” `print_refs` çš„é•¿ã€‚

    failed_borrow();
    // `failed_borrow` æœªåŒ…å«å¼•ç”¨ï¼Œå› æ­¤ä¸è¦æ±‚ `'a` é•¿äºå‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸï¼Œ
    // ä½† `'a` å¯¿å‘½ç¡®å®æ›´é•¿ã€‚å› ä¸ºè¯¥ç”Ÿå‘½å‘¨æœŸä»æœªè¢«çº¦æŸï¼Œæ‰€ä»¥é»˜è®¤ä¸º `'static`ã€‚
}

```



## å„åœºæ™¯ä¸­çš„å£°æ˜å‘¨æœŸ

### å‡½æ•°ç­¾åä¸­çš„ç”Ÿå‘½å‘¨æœŸ

æ’é™¤[çœç•¥](http://localhost:3000/scope/lifetime/elision.html)ï¼ˆelisionï¼‰çš„æƒ…å†µï¼Œå¸¦ä¸Šç”Ÿå‘½å‘¨æœŸçš„å‡½æ•°ç­¾åæœ‰ä¸€äº›é™åˆ¶ï¼š

- ä»»ä½•å¼•ç”¨**éƒ½å¿…é¡»**æ‹¥æœ‰æ ‡æ³¨å¥½çš„ç”Ÿå‘½å‘¨æœŸã€‚
- ä»»ä½•è¢«è¿”å›çš„å¼•ç”¨**éƒ½å¿…é¡»**æœ‰å’ŒæŸä¸ªè¾“å…¥é‡ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸæˆ–æ˜¯é™æ€ç±»å‹ï¼ˆ`static`ï¼‰ã€‚

å¦å¤–è¦æ³¨æ„ï¼Œå¦‚æœæ²¡æœ‰è¾“å…¥çš„å‡½æ•°è¿”å›å¼•ç”¨ï¼Œæœ‰æ—¶ä¼šå¯¼è‡´è¿”å›çš„å¼•ç”¨æŒ‡å‘æ— æ•ˆæ•°æ®ï¼Œè¿™ç§æƒ…å†µä¸‹ç¦æ­¢å®ƒè¿”å›è¿™æ ·çš„å¼•ç”¨ã€‚ä¸‹é¢ä¾‹å­å±•ç¤ºäº†ä¸€äº›åˆæ³•çš„å¸¦æœ‰ç”Ÿå‘½å‘¨æœŸçš„å‡½æ•°ï¼š



```rust
// ä¸€ä¸ªæ‹¥æœ‰ç”Ÿå‘½å‘¨æœŸ `'a` çš„è¾“å…¥å¼•ç”¨ï¼Œå…¶ä¸­ `'a` çš„å­˜æ´»æ—¶é—´
// è‡³å°‘ä¸å‡½æ•°çš„ä¸€æ ·é•¿ã€‚
fn print_one<'a>(x: &'a i32) {
    println!("`print_one`: x is {}", x);
}

// å¯å˜å¼•ç”¨åŒæ ·ä¹Ÿå¯èƒ½æ‹¥æœ‰ç”Ÿå‘½å‘¨æœŸã€‚
fn add_one<'a>(x: &'a mut i32) {
    *x += 1;
}

// æ‹¥æœ‰ä¸åŒç”Ÿå‘½å‘¨æœŸçš„å¤šä¸ªå…ƒç´ ã€‚å¯¹ä¸‹é¢è¿™ç§æƒ…å½¢ï¼Œä¸¤è€…å³ä½¿æ‹¥æœ‰
// ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸ `'a` ä¹Ÿæ²¡é—®é¢˜ï¼Œä½†å¯¹ä¸€äº›æ›´å¤æ‚çš„æƒ…å½¢ï¼Œå¯èƒ½
// å°±éœ€è¦ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸäº†ã€‚
fn print_multi<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("`print_multi`: x is {}, y is {}", x, y);
}

// è¿”å›ä¼ é€’è¿›æ¥çš„å¼•ç”¨ä¹Ÿæ˜¯å¯è¡Œçš„ã€‚
// ä½†å¿…é¡»è¿”å›æ­£ç¡®çš„ç”Ÿå‘½å‘¨æœŸã€‚
fn pass_x<'a, 'b>(x: &'a i32, _: &'b i32) -> &'a i32 { x }

//fn invalid_output<'a>() -> &'a String { &String::from("foo") }
// ä¸Šé¢ä»£ç æ˜¯æ— æ•ˆçš„ï¼š`'a` å­˜æ´»çš„æ—¶é—´å¿…é¡»æ¯”å‡½æ•°çš„é•¿ã€‚
// è¿™é‡Œçš„ `&String::from("foo")` å°†ä¼šåˆ›å»ºä¸€ä¸ª `String` ç±»å‹ï¼Œç„¶åå¯¹å®ƒå–å¼•ç”¨ã€‚
// æ•°æ®åœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶åˆ æ‰ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘æ— æ•ˆæ•°æ®çš„å¼•ç”¨ã€‚

fn main() {
    let x = 7;
    let y = 9;

    print_one(&x);
    print_multi(&x, &y);

    let z = pass_x(&x, &y);
    print_one(z);

    let mut t = 3;
    add_one(&mut t);
    print_one(&t);
}

```



### æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

æ–¹æ³•çš„æ ‡æ³¨å’Œå‡½æ•°ç±»ä¼¼ï¼š

```
struct Owner(i32);

impl Owner {
    // æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼Œå°±åƒç‹¬ç«‹çš„å‡½æ•°ä¸€æ ·ã€‚
    fn add_one<'a>(&'a mut self) { self.0 += 1; }
    fn print<'a>(&'a self) {
        println!("`print`: {}", self.0);
    }
}

fn main() {
    let mut owner  = Owner(18);

    owner.add_one();
    owner.print();
}
```

> è¯‘æ³¨ï¼šæ–¹æ³•ä¸€èˆ¬æ˜¯ä¸éœ€è¦æ ‡æ˜ç”Ÿå‘½å‘¨æœŸçš„ï¼Œå› ä¸º `self` çš„ç”Ÿå‘½å‘¨æœŸä¼šèµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œè¯¦è§ [TRPL](https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#ç”Ÿå‘½å‘¨æœŸçœç•¥lifetime-elision)ã€‚



### ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

åœ¨ç»“æ„ä½“ä¸­æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸä¹Ÿå’Œå‡½æ•°çš„ç±»ä¼¼ï¼š

```rust
// ä¸€ä¸ª `Borrowed` ç±»å‹ï¼Œå«æœ‰ä¸€ä¸ªæŒ‡å‘ `i32` ç±»å‹çš„å¼•ç”¨ã€‚
// è¯¥å¼•ç”¨å¿…é¡»æ¯” `Borrowed` å¯¿å‘½æ›´é•¿ã€‚
#[derive(Debug)]
struct Borrowed<'a>(&'a i32);

// å’Œå‰é¢ç±»ä¼¼ï¼Œè¿™é‡Œçš„ä¸¤ä¸ªå¼•ç”¨éƒ½å¿…é¡»æ¯”è¿™ä¸ªç»“æ„ä½“é•¿å¯¿ã€‚
#[derive(Debug)]
struct NamedBorrowed<'a> {
    x: &'a i32,
    y: &'a i32,
}

// ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œå…¶å–å€¼ä¸æ˜¯ `i32` ç±»å‹å°±æ˜¯ä¸€ä¸ªæŒ‡å‘ `i32` çš„å¼•ç”¨ã€‚
#[derive(Debug)]
enum Either<'a> {
    Num(i32),
    Ref(&'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&x);
    let double = NamedBorrowed { x: &x, y: &y };
    let reference = Either::Ref(&x);
    let number    = Either::Num(y);

    println!("x is borrowed in {:?}", single);
    println!("x and y are borrowed in {:?}", double);
    println!("x is borrowed in {:?}", reference);
    println!("y is *not* borrowed in {:?}", number);
}
```

> TODO y: æœ‰æ„ä¹‰çš„ä½¿ç”¨åœºæ™¯æ ·ä¾‹ï¼Ÿ



### traitä¸­çš„ç”Ÿå‘½å‘¨æœŸ

trait æ–¹æ³•ä¸­ç”Ÿå‘½æœŸçš„æ ‡æ³¨åŸºæœ¬ä¸Šä¸å‡½æ•°ç±»ä¼¼ã€‚æ³¨æ„ï¼Œ`impl` ä¹Ÿå¯èƒ½æœ‰ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨ã€‚

```rust
// å¸¦æœ‰ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„ç»“æ„ä½“ã€‚
#[derive(Debug)]
 struct Borrowed<'a> {
     x: &'a i32,
 }

// ç»™ impl æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸã€‚
impl<'a> Default for Borrowed<'a> {
    fn default() -> Self {
        Self {
            x: &10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!("b is {:?}", b);
}
```

> TODO y: æœ‰æ„ä¹‰çš„ä½¿ç”¨åœºæ™¯æ ·ä¾‹ï¼Ÿ





## ç”Ÿå‘½å‘¨æœŸçš„çº¦æŸ

å°±å¦‚æ³›å‹ç±»å‹èƒ½å¤Ÿè¢«çº¦æŸä¸€æ ·ï¼Œç”Ÿå‘½å‘¨æœŸï¼ˆå®ƒä»¬æœ¬èº«å°±æ˜¯æ³›å‹ï¼‰ä¹Ÿå¯ä»¥ä½¿ç”¨çº¦æŸã€‚**`:` å­—ç¬¦çš„æ„ä¹‰åœ¨è¿™é‡Œç¨å¾®æœ‰äº›ä¸åŒ**ï¼Œä¸è¿‡ `+` æ˜¯ç›¸åŒçš„ã€‚æ³¨æ„ä¸‹é¢çš„è¯´æ˜ï¼š

1. `T: 'a`ï¼šåœ¨ `T` ä¸­çš„**æ‰€æœ‰**å¼•ç”¨éƒ½å¿…é¡»æ¯”ç”Ÿå‘½å‘¨æœŸ `'a` æ´»å¾—æ›´é•¿ã€‚

2. `T: Trait + 'a`ï¼š`T` ç±»å‹å¿…é¡»å®ç° `Trait` traitï¼Œå¹¶ä¸”åœ¨ `T` ä¸­çš„**æ‰€æœ‰**å¼•ç”¨éƒ½å¿…é¡»æ¯” `'a` æ´»å¾—æ›´é•¿ã€‚

   > y: æ³›å‹ + ç”Ÿå‘½å‘¨æœŸ

ä¸‹é¢ä¾‹å­å±•ç¤ºäº†ä¸Šè¿°è¯­æ³•çš„å®é™…åº”ç”¨ï¼š

```rust
use std::fmt::Debug; // ç”¨äºçº¦æŸçš„ traitã€‚

#[derive(Debug)]
struct Ref<'a, T: 'a>(&'a T);
// `Ref` åŒ…å«ä¸€ä¸ªæŒ‡å‘æ³›å‹ç±»å‹ `T` çš„å¼•ç”¨ï¼Œå…¶ä¸­ `T` æ‹¥æœ‰ä¸€ä¸ªæœªçŸ¥çš„ç”Ÿå‘½å‘¨æœŸ
// `'a`ã€‚`T` æ‹¥æœ‰ç”Ÿå‘½å‘¨æœŸé™åˆ¶ï¼Œ `T` ä¸­çš„ä»»ä½•*å¼•ç”¨*éƒ½å¿…é¡»æ¯” `'a` æ´»å¾—æ›´é•¿ã€‚å¦å¤–
// `Ref` çš„ç”Ÿå‘½å‘¨æœŸä¹Ÿä¸èƒ½è¶…å‡º `'a`ã€‚

// ä¸€ä¸ªæ³›å‹å‡½æ•°ï¼Œä½¿ç”¨ `Debug` trait æ¥æ‰“å°å†…å®¹ã€‚
fn print<T>(t: T) where
    T: Debug {
    println!("`print`: t is {:?}", t);
}

// è¿™é‡Œæ¥å—ä¸€ä¸ªæŒ‡å‘ `T` çš„å¼•ç”¨ï¼Œå…¶ä¸­ `T` å®ç°äº† `Debug` traitï¼Œå¹¶ä¸”åœ¨ `T` ä¸­çš„
// æ‰€æœ‰*å¼•ç”¨*éƒ½å¿…é¡»æ¯” `'a'` å­˜æ´»æ—¶é—´æ›´é•¿ã€‚å¦å¤–ï¼Œ`'a` ä¹Ÿè¦æ¯”å‡½æ•°æ´»å¾—æ›´é•¿ã€‚
fn print_ref<'a, T>(t: &'a T) where
    T: Debug + 'a {
    println!("`print_ref`: t is {:?}", t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&x);

    print_ref(&ref_x);
    print(ref_x);
}
```



## ç”Ÿå‘½å‘¨æœŸçš„è½¬æ¢

ä¸€ä¸ªè¾ƒé•¿çš„ç”Ÿå‘½å‘¨æœŸå¯ä»¥å¼ºåˆ¶è½¬æˆä¸€ä¸ªè¾ƒçŸ­çš„ç”Ÿå‘½å‘¨æœŸï¼Œä½¿å®ƒåœ¨ä¸€ä¸ªé€šå¸¸æƒ…å†µä¸‹ä¸èƒ½å·¥ä½œçš„ä½œç”¨åŸŸå†…ä¹Ÿèƒ½æ­£å¸¸å·¥ä½œã€‚å¼ºåˆ¶è½¬æ¢å¯ç”±ç¼–è¯‘å™¨éšå¼åœ°æ¨å¯¼å¹¶æ‰§è¡Œï¼Œä¹Ÿå¯ä»¥é€šè¿‡å£°æ˜ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸçš„å½¢å¼å®ç°ã€‚

```rust
// åœ¨è¿™é‡Œï¼ŒRust æ¨å¯¼äº†ä¸€ä¸ªå°½å¯èƒ½çŸ­çš„ç”Ÿå‘½å‘¨æœŸã€‚
// ç„¶åè¿™ä¸¤ä¸ªå¼•ç”¨éƒ½è¢«å¼ºåˆ¶è½¬æˆè¿™ä¸ªç”Ÿå‘½å‘¨æœŸã€‚
fn multiply<'a>(first: &'a i32, second: &'a i32) -> i32 {
    first * second
}

// `<'a: 'b, 'b>` è¯»ä½œç”Ÿå‘½å‘¨æœŸ `'a` è‡³å°‘å’Œ `'b` ä¸€æ ·é•¿ã€‚
// åœ¨è¿™é‡Œæˆ‘ä»¬æˆ‘ä»¬æ¥å—äº†ä¸€ä¸ª `&'a i32` ç±»å‹å¹¶è¿”å›ä¸€ä¸ª `&'b i32` ç±»å‹ï¼Œè¿™æ˜¯
// å¼ºåˆ¶è½¬æ¢å¾—åˆ°çš„ç»“æœã€‚
fn choose_first<'a: 'b, 'b>(first: &'a i32, _: &'b i32) -> &'b i32 {
    first
}

fn main() {
    let first = 2; // è¾ƒé•¿çš„ç”Ÿå‘½å‘¨æœŸ

    {
        let second = 3; // è¾ƒçŸ­çš„ç”Ÿå‘½å‘¨æœŸ

        println!("The product is {}", multiply(&first, &second));
        println!("{} is the first", choose_first(&first, &second));
    };
}

```



> TODO y: é•¿è½¬çŸ­çš„æ„ä¹‰æ˜¯ï¼Ÿ



## staticç”Ÿå‘½å‘¨æœŸ

`'static` ç”Ÿå‘½å‘¨æœŸæ˜¯å¯èƒ½çš„ç”Ÿå‘½å‘¨æœŸä¸­æœ€é•¿çš„ï¼Œå®ƒä¼šåœ¨æ•´ä¸ªç¨‹åºè¿è¡Œçš„æ—¶æœŸä¸­å­˜åœ¨ã€‚`'static` ç”Ÿå‘½å‘¨æœŸä¹Ÿå¯è¢«å¼ºåˆ¶è½¬æ¢æˆä¸€ä¸ªæ›´çŸ­çš„ç”Ÿå‘½å‘¨æœŸã€‚æœ‰ä¸¤ç§æ–¹å¼ä½¿å˜é‡æ‹¥æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸï¼Œå®ƒä»¬éƒ½æŠŠæ•°æ®ä¿å­˜åœ¨å¯æ‰§è¡Œæ–‡ä»¶çš„åªè¯»å†…å­˜åŒºï¼š

- ä½¿ç”¨ `static` å£°æ˜æ¥äº§ç”Ÿå¸¸é‡ï¼ˆconstantï¼‰ã€‚
- äº§ç”Ÿä¸€ä¸ªæ‹¥æœ‰ `&'static str` ç±»å‹çš„ `string` å­—é¢é‡ã€‚

çœ‹ä¸‹é¢çš„ä¾‹å­ï¼Œäº†è§£åˆ—ä¸¾åˆ°çš„å„ä¸ªæ–¹æ³•ï¼š

```
// äº§ç”Ÿä¸€ä¸ªæ‹¥æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸçš„å¸¸é‡ã€‚
static NUM: i32 = 18;

// è¿”å›ä¸€ä¸ªæŒ‡å‘ `NUM` çš„å¼•ç”¨ï¼Œè¯¥å¼•ç”¨ä¸å– `NUM` çš„ `'static` ç”Ÿå‘½å‘¨æœŸï¼Œ
// è€Œæ˜¯è¢«å¼ºåˆ¶è½¬æ¢æˆå’Œè¾“å…¥å‚æ•°çš„ä¸€æ ·ã€‚
fn coerce_static<'a>(_: &'a i32) -> &'a i32 {
    &NUM
}

fn main() {
    {
        // äº§ç”Ÿä¸€ä¸ª `string` å­—é¢é‡å¹¶æ‰“å°å®ƒï¼š
        let static_string = "I'm in read-only memory";
        println!("static_string: {}", static_string);

        // å½“ `static_string` ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œè¯¥å¼•ç”¨ä¸èƒ½å†ä½¿ç”¨ï¼Œä¸è¿‡
        // æ•°æ®ä»ç„¶å­˜åœ¨äºäºŒè¿›åˆ¶æ–‡ä»¶é‡Œé¢ã€‚
    }

    {
        // äº§ç”Ÿä¸€ä¸ªæ•´å‹ç»™ `coerce_static` ä½¿ç”¨ï¼š
        let lifetime_num = 9;

        println!("static NUM: {}", &NUM);
        // å°†å¯¹ `NUM` çš„å¼•ç”¨å¼ºåˆ¶è½¬æ¢æˆ `lifetime_num` çš„ç”Ÿå‘½å‘¨æœŸï¼š
        let coerced_static = coerce_static(&lifetime_num);

        println!("coerced_static: {}", coerced_static);
        println!("static NUM: {}", &NUM);
    }

    println!("NUM: {} stays accessible!", NUM);
}
```

> TODO y: æ„Ÿè§‰è«åå…¶å¦™å•Šï¼Œå¹²äº†ä¸ªå•¥ï¼Ÿ æ„ä¹‰ï¼Ÿ



## çœç•¥ç”Ÿå‘½å‘¨æœŸelision

> y: ä¸€èˆ¬å°±è¿™æ ·äº†



æœ‰äº›ç”Ÿå‘½å‘¨æœŸçš„æ¨¡å¼å¤ªå¸¸ç”¨äº†ï¼Œæ‰€ä»¥å€Ÿç”¨æ£€æŸ¥å™¨å°†ä¼šéšå¼åœ°æ·»åŠ å®ƒä»¬ä»¥å‡å°‘ç¨‹åºè¾“å…¥é‡å’Œå¢å¼ºå¯è¯»æ€§ã€‚è¿™ç§éšå¼æ·»åŠ ç”Ÿå‘½å‘¨æœŸçš„è¿‡ç¨‹ç§°ä¸ºçœç•¥ï¼ˆelisionï¼‰ã€‚åœ¨ Rust ä½¿ç”¨çœç•¥ä»…ä»…æ˜¯å› ä¸ºè¿™äº›æ¨¡å¼å¤ªæ™®éäº†ã€‚

ä¸‹é¢ä»£ç å±•ç¤ºäº†ä¸€äº›çœç•¥çš„ä¾‹å­ã€‚å¯¹äºçœç•¥çš„è¯¦ç»†æè¿°ï¼Œå¯ä»¥å‚è€ƒå®˜æ–¹æ–‡æ¡£çš„[ç”Ÿå‘½å‘¨æœŸçœç•¥](https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#ç”Ÿå‘½å‘¨æœŸçœç•¥lifetime-elision)ã€‚

```rust
// `elided_input` å’Œ `annotated_input` äº‹å®ä¸Šæ‹¥æœ‰ç›¸åŒçš„ç­¾åï¼Œ
// `elided_input` çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«ç¼–è¯‘å™¨è‡ªåŠ¨æ·»åŠ ï¼š
fn elided_input(x: &i32) {
    println!("`elided_input`: {}", x)
}

fn annotated_input<'a>(x: &'a i32) {
    println!("`annotated_input`: {}", x)
}

// ç±»ä¼¼åœ°ï¼Œ`elided_pass` å’Œ `annotated_pass` ä¹Ÿæ‹¥æœ‰ç›¸åŒçš„ç­¾åï¼Œ
// ç”Ÿå‘½å‘¨æœŸä¼šè¢«éšå¼åœ°æ·»åŠ è¿› `elided_pass`ï¼š
fn elided_pass(x: &i32) -> &i32 { x }

fn annotated_pass<'a>(x: &'a i32) -> &'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&x);
    annotated_input(&x);

    println!("`elided_pass`: {}", elided_pass(&x));
    println!("`annotated_pass`: {}", annotated_pass(&x));
}
```



## misc

**å†…å­˜ç®¡ç†**ï¼š
* æ‰‹åŠ¨å†…å­˜ç®¡ç†
* è‡ªåŠ¨å†…å­˜ç®¡ç†
  * åƒåœ¾å›æ”¶ï¼ˆè¿è¡Œæ—¶ï¼‰
  * ...

* ä¸€ä¸ªèµ„æºï¼ŒåŒä¸€ä¸ªæ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªowner
  é‡ç”¨ï¼ˆæ‰€ä»¥ä¸æ˜¯moveä¹Ÿä¸æ˜¯copyï¼‰è¿™ä¸ªèµ„æºï¼Œåªèƒ½ å¼•ç”¨/borrow
* å¤„ç†å¼•ç”¨æ—¶ï¼Œå¯ä»¥æ‰‹åŠ¨æ·»åŠ ç”Ÿå­˜æœŸæ³¨è§£ï¼Œä»¥ä¾¿äºç¼–è¯‘å™¨åˆ¤æ–­
  å‡½æ•°å®šä¹‰ä¸­çš„ç”Ÿå­˜æœŸæ³¨è§£ä¼šï¼ˆéšå¼ï¼‰è‡ªåŠ¨æ·»åŠ 
  ä¼šåœ¨ç¼–è¯‘å™¨æ£€æŸ¥ç”Ÿå­˜æœŸæ³¨è§£ï¼š ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡ä½¿ç”¨ï¼ˆæŸèµ„æº/æ•°æ®ï¼‰
* å¯¹å†…å­˜çš„ç®¡ç†æ“ä½œ
  * ä¸æ˜¾å¼çš„ dropï¼ˆfreeï¼Ÿï¼‰æ•°æ®
  * æ²¡æœ‰ç±»ä¼¼gcè¯­è¨€çš„å¯¹è±¡ææ„æ—¶çš„finalizeè°ƒç”¨
  * ä¼šåœ¨ç”Ÿå­˜æœŸç»“æŸï¼ˆgo out of scopeï¼‰æ—¶æ‰§è¡Œdeallocation call
    è¿™ä¸ª

**ç”Ÿå­˜æœŸç»“æŸ**ï¼š
* åŒä¸€å±‚çº§SCOPEæœ€åä¸€æ¬¡ä½¿ç”¨ï¼›
* å‡ºäº†å½“å‰å±‚çº§scopeï¼ˆå¦‚æœæ˜¯scopeå†…çš„bindingï¼‰ï¼›


**ç”Ÿå­˜æœŸçº¦æŸ**
å¦‚ `x.a`è¿™æ ·è®¿é—®ï¼Œè¦ç¡®ä¿xç”Ÿå­˜æœŸå†…aæ²¡æœ‰è¢«é‡Šæ”¾ã€‚

#### ç”Ÿå­˜æœŸæ³¨è§£

* ä¸»è¦ç”¨æ¥æ ‡è¯†ã€çº¦æŸç”Ÿå­˜æœŸ

* æ ¼å¼ `'`å¼€å¤´ï¼Œä¸€èˆ¬çº¦å®šï¼š åé¢ç”¨ä¸€ä¸ªå°å†™å­—æ¯ï¼Œå¦‚ `'a`ã€‚ ä½¿ç”¨å¤šä¸ªæ—¶ï¼ŒæŒ‰ç…§å­—æ¯é¡ºåºä¸€æ¬¡ä½¿ç”¨

* ä½¿ç”¨åœºæ™¯
  ç¤ºä¾‹è§ä¸‹æ–‡
  * å‡½æ•°å£°æ˜
    
  * ç»“æ„ä½“ã€æšä¸¾å£°æ˜
  * implã€trait
  * æ³›å‹

* çœç•¥æ³¨è§£

  * `fn`
    æ¡ä»¶æ˜¯å‚æ•°åˆ—è¡¨æ»¡è¶³å…¶ä¸€ï¼š

    * åªæœ‰ä¸€ä¸ªå…¥å‚æ˜¯å¼•ç”¨
      åˆ™æ‰€æœ‰å‡ºå‚ä¸­çœç•¥çš„ç”Ÿå­˜æœŸæ³¨è§£éƒ½ä¸ºæ­¤
      `..(x: i32, y: &str) -> &str` â†’ `..<'a>(x: i32, y: &'a str) -> &'a str`
    
    * æœ‰`&self`æˆ–`&mut self`
      åˆ™...éƒ½ä¸ºæ­¤
      `impl Impl{ fn function(&self, x: &str) -> &str {} }` â†’
`impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`
    > ä½†å¥½åƒè¿˜æœ‰ä¸€ç§æƒ…å†µå°±æ˜¯æ‰€æœ‰å¼•ç”¨ä¼ å‚çš„å…¥å‚çš„ç”Ÿå­˜å‘¨æœŸæ³¨è§£éƒ½ä¸åŒï¼Œé‚£ä¹ˆä¹Ÿå¯ä»¥çœç•¥ã€‚ ä½†æ­¤æ—¶å‡ºå‚çš„ç”Ÿå­˜å‘¨æœŸçº¦æŸæ˜¯ï¼Ÿ
    > `..(x: &str, y: &str)` â†’ `..<'a, 'b>(x: &'a str, y: &'b str)`

  * `impl` - æœªæ¥æ”¯æŒ

* `'static`
  * ä¿ç•™çš„ç‰¹æ®Šæ³¨è§£
  * è¡¨ç¤ºç”Ÿå­˜æœŸåœ¨æ•´ä¸ªç¨‹åºç”Ÿå­˜æœŸé—´éƒ½æœ‰æ•ˆ
    æ•°æ®ä¿å­˜åœ¨æ•°æ®æ®µï¼Œè®¿é—®æ•°æ®ä¸ä¼šgg
    ```rust
    static N: i32 = 5; // A constant with 'static lifetime
    let a = "Hello, world."; // a: &'static str
    fn index() -> &'static str { // No need to mention <'static> ; fn index Ì¶<Ì¶'Ì¶sÌ¶tÌ¶aÌ¶tÌ¶iÌ¶cÌ¶>Ì¶ 
        "Hello, world!"
    }
    ```

**å‡½æ•°å£°æ˜ä¸­çš„ç”Ÿå­˜æœŸæ³¨è§£**
> ä¸å¤ªæ¸…é™¤å…·ä½“çš„æ„ä¹‰

```rust
// No inputs, return a reference
fn function<'a>() -> &'a str {}

// Single input
fn function<'a>(x: &'a str) {}

// Single input and output, both have the same lifetime
// The output should live at least as long as input exists
fn function<'a>(x: &'a str) -> &'a str {}

// Multiple inputs, only one input and the output share same lifetime
// The output should live at least as long as y exists
fn function<'a>(x: i32, y: &'a str) -> &'a str {}

// Multiple inputs, both inputs and the output share same lifetime
// The output should live at least as long as x and y exist
fn function<'a>(x: &'a str, y: &'a str) -> &'a str {}

// Multiple inputs, inputs can have different lifetimes ğŸ”
// The output should live at least as long as x exists
fn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}
```

**ç»“æ„ä½“ã€æšä¸¾ä¸­çš„ç”Ÿå­˜æœŸæ³¨è§£**
```rust
// Single element
// Data of x should live at least as long as Struct exists
struct Struct<'a> {
    x: &'a str
}

// Multiple elements
// Data of x and y should live at least as long as Struct exists
struct Struct<'a> {
    x: &'a str,
    y: &'a str
}


// Variant with a single element
// Data of the variant should live at least as long as Enum exists
enum Enum<'a> {
    Variant(&'a Type)
}
```

**implä¸­çš„ç”Ÿå­˜æœŸæ³¨è§£**
```rust
struct Struct<'a> {
    x: &'a str
}
    impl<'a> Struct<'a> {
        fn function<'a>(&self) -> &'a str {
            self.x
        }
    }


struct Struct<'a> {
    x: &'a str,
    y: &'a str
}
    impl<'a> Struct<'a> {
        fn new(x: &'a str, y: &'a str) -> Struct<'a> { // No need to specify <'a> after new; impl already has it
          Struct {
              x : x,
              y : y
          }
        }
    }


// ğŸ”
impl<'a> Trait<'a> for Type
impl<'a> Trait for Type<'a>
```

```rust
// ğŸ”
fn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)
struct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }
enum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }
impl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }
```